<?php
/**
 * EnvelopeControllerApi
 * PHP version 7.4
 *
 * @category Class
 * @package  DocStudio\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * DocStudio Api Documentation
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: R125.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace DocStudio\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use DocStudio\Client\ApiException;
use DocStudio\Client\Configuration;
use DocStudio\Client\HeaderSelector;
use DocStudio\Client\ObjectSerializer;

/**
 * EnvelopeControllerApi Class Doc Comment
 *
 * @category Class
 * @package  DocStudio\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EnvelopeControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'acceptUserPendingInvitations' => [
            'application/json',
        ],
        'addEnvelopesIntoChain' => [
            'application/json',
        ],
        'approve' => [
            'application/json',
        ],
        'archive' => [
            'application/json',
        ],
        'cancelApprovalFlow' => [
            'application/json',
        ],
        'cancelEnvelopeDelegation' => [
            'application/json',
        ],
        'cancelEnvelopes' => [
            'application/json',
        ],
        'check' => [
            'application/json',
        ],
        'checkEnvelopeHasActiveRole' => [
            'application/json',
        ],
        'checkUserHasInvitations' => [
            'application/json',
        ],
        'cloneAttachment' => [
            'application/json',
        ],
        'confirmInvite' => [
            'application/json',
        ],
        'continueScenarioStep' => [
            'application/json',
        ],
        'create' => [
            'application/json',
        ],
        'createAttachment' => [
            'multipart/form-data',
        ],
        'createEnvelopeComment' => [
            'application/json',
        ],
        'createPdfAttachment' => [
            'multipart/form-data',
        ],
        'delegateEnvelopes' => [
            'application/json',
        ],
        'deleteDrafts' => [
            'application/json',
        ],
        'deleteEnvelopeComment' => [
            'application/json',
        ],
        'downloadEnvelopeAttachment' => [
            'application/json',
        ],
        'downloadFinalPdf' => [
            'application/json',
        ],
        'downloadSharedAttachment' => [
            'application/json',
        ],
        'envelopeApproval' => [
            'application/json',
        ],
        'envelopeApprovalHistory' => [
            'application/json',
        ],
        'fill' => [
            'application/json',
        ],
        'generateStamp' => [
            'application/json',
        ],
        'getActiveRoles' => [
            'application/json',
        ],
        'getApprovalFlow' => [
            'application/json',
        ],
        'getAttachmentPageSizes' => [
            'application/json',
        ],
        'getChainEnvelopes' => [
            'application/json',
        ],
        'getDocumentFileForSign' => [
            'application/json',
        ],
        'getDocumentForSign' => [
            'application/json',
        ],
        'getDocumentPrintVersion' => [
            'application/json',
        ],
        'getDocumentsForSign' => [
            'application/json',
        ],
        'getEnvelopeByUuid' => [
            'application/json',
        ],
        'getEnvelopeComments' => [
            'application/json',
        ],
        'getEnvelopeInviteAuthorized' => [
            'application/json',
        ],
        'getEnvelopeInviteUnauthorized' => [
            'application/json',
        ],
        'getEnvelopeSharedZip' => [
            'application/json',
        ],
        'getEnvelopeZip' => [
            'application/json',
        ],
        'getMassSigningReport' => [
            'application/json',
        ],
        'getUserPendingInvitations' => [
            'application/json',
        ],
        'mergeEnvelopesIntoChain' => [
            'application/json',
        ],
        'oneTimeSend' => [
            'application/json',
        ],
        'quickSendExternalDocuments' => [
            'multipart/form-data',
        ],
        'recycleBin' => [
            'application/json',
        ],
        'removeEnvelopeFromChain' => [
            'application/json',
        ],
        'resendNotifications' => [
            'application/json',
        ],
        'resolvedEnvelopeComment' => [
            'application/json',
        ],
        'revokeEnvelopeSharing' => [
            'application/json',
        ],
        'send' => [
            'application/json',
        ],
        'sendByTemplateCode' => [
            'application/json',
        ],
        'sendForApproval' => [
            'application/json',
        ],
        'shareEnvelopesByEmail' => [
            'application/json',
        ],
        'shareEnvelopesCopy' => [
            'application/json',
        ],
        'sign' => [
            'application/json',
        ],
        'signSES' => [
            'application/json',
        ],
        'updateEnvelope' => [
            'application/json',
        ],
        'updateEnvelopeComment' => [
            'application/json',
        ],
        'updateEnvelopeCommentAccess' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation acceptUserPendingInvitations
     *
     * Accept user&#39;s pending invitations
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acceptUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function acceptUserPendingInvitations($mailbox, $request_body, string $contentType = self::contentTypes['acceptUserPendingInvitations'][0])
    {
        $this->acceptUserPendingInvitationsWithHttpInfo($mailbox, $request_body, $contentType);
    }

    /**
     * Operation acceptUserPendingInvitationsWithHttpInfo
     *
     * Accept user&#39;s pending invitations
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acceptUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function acceptUserPendingInvitationsWithHttpInfo($mailbox, $request_body, string $contentType = self::contentTypes['acceptUserPendingInvitations'][0])
    {
        $request = $this->acceptUserPendingInvitationsRequest($mailbox, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation acceptUserPendingInvitationsAsync
     *
     * Accept user&#39;s pending invitations
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acceptUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptUserPendingInvitationsAsync($mailbox, $request_body, string $contentType = self::contentTypes['acceptUserPendingInvitations'][0])
    {
        return $this->acceptUserPendingInvitationsAsyncWithHttpInfo($mailbox, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acceptUserPendingInvitationsAsyncWithHttpInfo
     *
     * Accept user&#39;s pending invitations
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acceptUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptUserPendingInvitationsAsyncWithHttpInfo($mailbox, $request_body, string $contentType = self::contentTypes['acceptUserPendingInvitations'][0])
    {
        $returnType = '';
        $request = $this->acceptUserPendingInvitationsRequest($mailbox, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acceptUserPendingInvitations'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acceptUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function acceptUserPendingInvitationsRequest($mailbox, $request_body, string $contentType = self::contentTypes['acceptUserPendingInvitations'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling acceptUserPendingInvitations'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling acceptUserPendingInvitations'
            );
        }


        $resourcePath = '/api/v1/envelope/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addEnvelopesIntoChain
     *
     * Add envelopes into chain
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addEnvelopesIntoChain($chain_uuid, $mailbox, $request_body, string $contentType = self::contentTypes['addEnvelopesIntoChain'][0])
    {
        $this->addEnvelopesIntoChainWithHttpInfo($chain_uuid, $mailbox, $request_body, $contentType);
    }

    /**
     * Operation addEnvelopesIntoChainWithHttpInfo
     *
     * Add envelopes into chain
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addEnvelopesIntoChainWithHttpInfo($chain_uuid, $mailbox, $request_body, string $contentType = self::contentTypes['addEnvelopesIntoChain'][0])
    {
        $request = $this->addEnvelopesIntoChainRequest($chain_uuid, $mailbox, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation addEnvelopesIntoChainAsync
     *
     * Add envelopes into chain
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addEnvelopesIntoChainAsync($chain_uuid, $mailbox, $request_body, string $contentType = self::contentTypes['addEnvelopesIntoChain'][0])
    {
        return $this->addEnvelopesIntoChainAsyncWithHttpInfo($chain_uuid, $mailbox, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addEnvelopesIntoChainAsyncWithHttpInfo
     *
     * Add envelopes into chain
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addEnvelopesIntoChainAsyncWithHttpInfo($chain_uuid, $mailbox, $request_body, string $contentType = self::contentTypes['addEnvelopesIntoChain'][0])
    {
        $returnType = '';
        $request = $this->addEnvelopesIntoChainRequest($chain_uuid, $mailbox, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addEnvelopesIntoChain'
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addEnvelopesIntoChainRequest($chain_uuid, $mailbox, $request_body, string $contentType = self::contentTypes['addEnvelopesIntoChain'][0])
    {

        // verify the required parameter 'chain_uuid' is set
        if ($chain_uuid === null || (is_array($chain_uuid) && count($chain_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chain_uuid when calling addEnvelopesIntoChain'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling addEnvelopesIntoChain'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling addEnvelopesIntoChain'
            );
        }
        

        $resourcePath = '/api/v1/envelope/chain/{chainUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($chain_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'chainUuid' . '}',
                ObjectSerializer::toPathValue($chain_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation approve
     *
     * Approve envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approve'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function approve($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['approve'][0])
    {
        list($response) = $this->approveWithHttpInfo($mailbox, $bulk_envelope_action_dto, $contentType);
        return $response;
    }

    /**
     * Operation approveWithHttpInfo
     *
     * Approve envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approve'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveWithHttpInfo($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['approve'][0])
    {
        $request = $this->approveRequest($mailbox, $bulk_envelope_action_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approveAsync
     *
     * Approve envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveAsync($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['approve'][0])
    {
        return $this->approveAsyncWithHttpInfo($mailbox, $bulk_envelope_action_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveAsyncWithHttpInfo
     *
     * Approve envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveAsyncWithHttpInfo($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['approve'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->approveRequest($mailbox, $bulk_envelope_action_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approve'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approveRequest($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['approve'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling approve'
            );
        }

        // verify the required parameter 'bulk_envelope_action_dto' is set
        if ($bulk_envelope_action_dto === null || (is_array($bulk_envelope_action_dto) && count($bulk_envelope_action_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_envelope_action_dto when calling approve'
            );
        }


        $resourcePath = '/api/v1/envelope/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_envelope_action_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_envelope_action_dto));
            } else {
                $httpBody = $bulk_envelope_action_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation archive
     *
     * Archive envelopes
     *
     * @param  bool $flag flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archive'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function archive($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['archive'][0])
    {
        $this->archiveWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, $contentType);
    }

    /**
     * Operation archiveWithHttpInfo
     *
     * Archive envelopes
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archive'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function archiveWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['archive'][0])
    {
        $request = $this->archiveRequest($flag, $mailbox, $bulk_envelope_action_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation archiveAsync
     *
     * Archive envelopes
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveAsync($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['archive'][0])
    {
        return $this->archiveAsyncWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation archiveAsyncWithHttpInfo
     *
     * Archive envelopes
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveAsyncWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['archive'][0])
    {
        $returnType = '';
        $request = $this->archiveRequest($flag, $mailbox, $bulk_envelope_action_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'archive'
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function archiveRequest($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['archive'][0])
    {

        // verify the required parameter 'flag' is set
        if ($flag === null || (is_array($flag) && count($flag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flag when calling archive'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling archive'
            );
        }

        // verify the required parameter 'bulk_envelope_action_dto' is set
        if ($bulk_envelope_action_dto === null || (is_array($bulk_envelope_action_dto) && count($bulk_envelope_action_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_envelope_action_dto when calling archive'
            );
        }


        $resourcePath = '/api/v1/envelope/archive/{flag}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($flag !== null) {
            $resourcePath = str_replace(
                '{' . 'flag' . '}',
                ObjectSerializer::toPathValue($flag),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_envelope_action_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_envelope_action_dto));
            } else {
                $httpBody = $bulk_envelope_action_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelApprovalFlow
     *
     * Cancel envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelApprovalFlow'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelApprovalFlow($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['cancelApprovalFlow'][0])
    {
        $this->cancelApprovalFlowWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, $contentType);
    }

    /**
     * Operation cancelApprovalFlowWithHttpInfo
     *
     * Cancel envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelApprovalFlow'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelApprovalFlowWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['cancelApprovalFlow'][0])
    {
        $request = $this->cancelApprovalFlowRequest($envelope_uuid, $flow_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelApprovalFlowAsync
     *
     * Cancel envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelApprovalFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelApprovalFlowAsync($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['cancelApprovalFlow'][0])
    {
        return $this->cancelApprovalFlowAsyncWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelApprovalFlowAsyncWithHttpInfo
     *
     * Cancel envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelApprovalFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelApprovalFlowAsyncWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['cancelApprovalFlow'][0])
    {
        $returnType = '';
        $request = $this->cancelApprovalFlowRequest($envelope_uuid, $flow_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelApprovalFlow'
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelApprovalFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelApprovalFlowRequest($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['cancelApprovalFlow'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling cancelApprovalFlow'
            );
        }

        // verify the required parameter 'flow_uuid' is set
        if ($flow_uuid === null || (is_array($flow_uuid) && count($flow_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_uuid when calling cancelApprovalFlow'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling cancelApprovalFlow'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/approval/{flowUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }
        // path params
        if ($flow_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'flowUuid' . '}',
                ObjectSerializer::toPathValue($flow_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelEnvelopeDelegation
     *
     * Cancel envelope delegation
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeCancelDelegationDTO $envelope_cancel_delegation_dto envelope_cancel_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopeDelegation'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelEnvelopeDelegation($mailbox, $envelope_cancel_delegation_dto, string $contentType = self::contentTypes['cancelEnvelopeDelegation'][0])
    {
        $this->cancelEnvelopeDelegationWithHttpInfo($mailbox, $envelope_cancel_delegation_dto, $contentType);
    }

    /**
     * Operation cancelEnvelopeDelegationWithHttpInfo
     *
     * Cancel envelope delegation
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeCancelDelegationDTO $envelope_cancel_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopeDelegation'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelEnvelopeDelegationWithHttpInfo($mailbox, $envelope_cancel_delegation_dto, string $contentType = self::contentTypes['cancelEnvelopeDelegation'][0])
    {
        $request = $this->cancelEnvelopeDelegationRequest($mailbox, $envelope_cancel_delegation_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelEnvelopeDelegationAsync
     *
     * Cancel envelope delegation
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeCancelDelegationDTO $envelope_cancel_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopeDelegation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelEnvelopeDelegationAsync($mailbox, $envelope_cancel_delegation_dto, string $contentType = self::contentTypes['cancelEnvelopeDelegation'][0])
    {
        return $this->cancelEnvelopeDelegationAsyncWithHttpInfo($mailbox, $envelope_cancel_delegation_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelEnvelopeDelegationAsyncWithHttpInfo
     *
     * Cancel envelope delegation
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeCancelDelegationDTO $envelope_cancel_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopeDelegation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelEnvelopeDelegationAsyncWithHttpInfo($mailbox, $envelope_cancel_delegation_dto, string $contentType = self::contentTypes['cancelEnvelopeDelegation'][0])
    {
        $returnType = '';
        $request = $this->cancelEnvelopeDelegationRequest($mailbox, $envelope_cancel_delegation_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelEnvelopeDelegation'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeCancelDelegationDTO $envelope_cancel_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopeDelegation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelEnvelopeDelegationRequest($mailbox, $envelope_cancel_delegation_dto, string $contentType = self::contentTypes['cancelEnvelopeDelegation'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling cancelEnvelopeDelegation'
            );
        }

        // verify the required parameter 'envelope_cancel_delegation_dto' is set
        if ($envelope_cancel_delegation_dto === null || (is_array($envelope_cancel_delegation_dto) && count($envelope_cancel_delegation_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_cancel_delegation_dto when calling cancelEnvelopeDelegation'
            );
        }


        $resourcePath = '/api/v1/envelope/delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_cancel_delegation_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_cancel_delegation_dto));
            } else {
                $httpBody = $envelope_cancel_delegation_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelEnvelopes
     *
     * Cancel envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvCancellationRequestDTO $env_cancellation_request_dto env_cancellation_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function cancelEnvelopes($mailbox, $env_cancellation_request_dto, string $contentType = self::contentTypes['cancelEnvelopes'][0])
    {
        list($response) = $this->cancelEnvelopesWithHttpInfo($mailbox, $env_cancellation_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation cancelEnvelopesWithHttpInfo
     *
     * Cancel envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvCancellationRequestDTO $env_cancellation_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelEnvelopesWithHttpInfo($mailbox, $env_cancellation_request_dto, string $contentType = self::contentTypes['cancelEnvelopes'][0])
    {
        $request = $this->cancelEnvelopesRequest($mailbox, $env_cancellation_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelEnvelopesAsync
     *
     * Cancel envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvCancellationRequestDTO $env_cancellation_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelEnvelopesAsync($mailbox, $env_cancellation_request_dto, string $contentType = self::contentTypes['cancelEnvelopes'][0])
    {
        return $this->cancelEnvelopesAsyncWithHttpInfo($mailbox, $env_cancellation_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelEnvelopesAsyncWithHttpInfo
     *
     * Cancel envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvCancellationRequestDTO $env_cancellation_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelEnvelopesAsyncWithHttpInfo($mailbox, $env_cancellation_request_dto, string $contentType = self::contentTypes['cancelEnvelopes'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->cancelEnvelopesRequest($mailbox, $env_cancellation_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelEnvelopes'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvCancellationRequestDTO $env_cancellation_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelEnvelopesRequest($mailbox, $env_cancellation_request_dto, string $contentType = self::contentTypes['cancelEnvelopes'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling cancelEnvelopes'
            );
        }

        // verify the required parameter 'env_cancellation_request_dto' is set
        if ($env_cancellation_request_dto === null || (is_array($env_cancellation_request_dto) && count($env_cancellation_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_cancellation_request_dto when calling cancelEnvelopes'
            );
        }


        $resourcePath = '/api/v1/envelope/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_cancellation_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_cancellation_request_dto));
            } else {
                $httpBody = $env_cancellation_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation check
     *
     * Check an envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDTO $env_dto env_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['check'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\ValidationResponseDTO
     */
    public function check($mailbox, $env_dto, string $contentType = self::contentTypes['check'][0])
    {
        list($response) = $this->checkWithHttpInfo($mailbox, $env_dto, $contentType);
        return $response;
    }

    /**
     * Operation checkWithHttpInfo
     *
     * Check an envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDTO $env_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['check'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\ValidationResponseDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkWithHttpInfo($mailbox, $env_dto, string $contentType = self::contentTypes['check'][0])
    {
        $request = $this->checkRequest($mailbox, $env_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\ValidationResponseDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\ValidationResponseDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\ValidationResponseDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\ValidationResponseDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\ValidationResponseDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkAsync
     *
     * Check an envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDTO $env_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['check'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkAsync($mailbox, $env_dto, string $contentType = self::contentTypes['check'][0])
    {
        return $this->checkAsyncWithHttpInfo($mailbox, $env_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkAsyncWithHttpInfo
     *
     * Check an envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDTO $env_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['check'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkAsyncWithHttpInfo($mailbox, $env_dto, string $contentType = self::contentTypes['check'][0])
    {
        $returnType = '\DocStudio\Client\Model\ValidationResponseDTO';
        $request = $this->checkRequest($mailbox, $env_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'check'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDTO $env_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['check'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkRequest($mailbox, $env_dto, string $contentType = self::contentTypes['check'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling check'
            );
        }

        // verify the required parameter 'env_dto' is set
        if ($env_dto === null || (is_array($env_dto) && count($env_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_dto when calling check'
            );
        }


        $resourcePath = '/api/v1/envelope/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_dto));
            } else {
                $httpBody = $env_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkEnvelopeHasActiveRole
     *
     * Check envelope has active role
     *
     * @param  string $envelope_uuid UUID of envelope (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEnvelopeHasActiveRole'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function checkEnvelopeHasActiveRole($envelope_uuid, $mailbox, string $contentType = self::contentTypes['checkEnvelopeHasActiveRole'][0])
    {
        $this->checkEnvelopeHasActiveRoleWithHttpInfo($envelope_uuid, $mailbox, $contentType);
    }

    /**
     * Operation checkEnvelopeHasActiveRoleWithHttpInfo
     *
     * Check envelope has active role
     *
     * @param  string $envelope_uuid UUID of envelope (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEnvelopeHasActiveRole'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkEnvelopeHasActiveRoleWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['checkEnvelopeHasActiveRole'][0])
    {
        $request = $this->checkEnvelopeHasActiveRoleRequest($envelope_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation checkEnvelopeHasActiveRoleAsync
     *
     * Check envelope has active role
     *
     * @param  string $envelope_uuid UUID of envelope (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEnvelopeHasActiveRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkEnvelopeHasActiveRoleAsync($envelope_uuid, $mailbox, string $contentType = self::contentTypes['checkEnvelopeHasActiveRole'][0])
    {
        return $this->checkEnvelopeHasActiveRoleAsyncWithHttpInfo($envelope_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkEnvelopeHasActiveRoleAsyncWithHttpInfo
     *
     * Check envelope has active role
     *
     * @param  string $envelope_uuid UUID of envelope (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEnvelopeHasActiveRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkEnvelopeHasActiveRoleAsyncWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['checkEnvelopeHasActiveRole'][0])
    {
        $returnType = '';
        $request = $this->checkEnvelopeHasActiveRoleRequest($envelope_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkEnvelopeHasActiveRole'
     *
     * @param  string $envelope_uuid UUID of envelope (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEnvelopeHasActiveRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkEnvelopeHasActiveRoleRequest($envelope_uuid, $mailbox, string $contentType = self::contentTypes['checkEnvelopeHasActiveRole'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling checkEnvelopeHasActiveRole'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling checkEnvelopeHasActiveRole'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/has-active-role';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkUserHasInvitations
     *
     * Check user has pending invitations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUserHasInvitations'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function checkUserHasInvitations(string $contentType = self::contentTypes['checkUserHasInvitations'][0])
    {
        $this->checkUserHasInvitationsWithHttpInfo($contentType);
    }

    /**
     * Operation checkUserHasInvitationsWithHttpInfo
     *
     * Check user has pending invitations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUserHasInvitations'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkUserHasInvitationsWithHttpInfo(string $contentType = self::contentTypes['checkUserHasInvitations'][0])
    {
        $request = $this->checkUserHasInvitationsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation checkUserHasInvitationsAsync
     *
     * Check user has pending invitations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUserHasInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkUserHasInvitationsAsync(string $contentType = self::contentTypes['checkUserHasInvitations'][0])
    {
        return $this->checkUserHasInvitationsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkUserHasInvitationsAsyncWithHttpInfo
     *
     * Check user has pending invitations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUserHasInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkUserHasInvitationsAsyncWithHttpInfo(string $contentType = self::contentTypes['checkUserHasInvitations'][0])
    {
        $returnType = '';
        $request = $this->checkUserHasInvitationsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkUserHasInvitations'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUserHasInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkUserHasInvitationsRequest(string $contentType = self::contentTypes['checkUserHasInvitations'][0])
    {


        $resourcePath = '/api/v1/envelope/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloneAttachment
     *
     * Clone an existing attachment
     *
     * @param  string $attachment_uuid attachment_uuid (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\UploadedAttachmentDTO
     */
    public function cloneAttachment($attachment_uuid, $mailbox, string $contentType = self::contentTypes['cloneAttachment'][0])
    {
        list($response) = $this->cloneAttachmentWithHttpInfo($attachment_uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation cloneAttachmentWithHttpInfo
     *
     * Clone an existing attachment
     *
     * @param  string $attachment_uuid (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\UploadedAttachmentDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneAttachmentWithHttpInfo($attachment_uuid, $mailbox, string $contentType = self::contentTypes['cloneAttachment'][0])
    {
        $request = $this->cloneAttachmentRequest($attachment_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\UploadedAttachmentDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\UploadedAttachmentDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\UploadedAttachmentDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\UploadedAttachmentDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\UploadedAttachmentDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloneAttachmentAsync
     *
     * Clone an existing attachment
     *
     * @param  string $attachment_uuid (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneAttachmentAsync($attachment_uuid, $mailbox, string $contentType = self::contentTypes['cloneAttachment'][0])
    {
        return $this->cloneAttachmentAsyncWithHttpInfo($attachment_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneAttachmentAsyncWithHttpInfo
     *
     * Clone an existing attachment
     *
     * @param  string $attachment_uuid (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneAttachmentAsyncWithHttpInfo($attachment_uuid, $mailbox, string $contentType = self::contentTypes['cloneAttachment'][0])
    {
        $returnType = '\DocStudio\Client\Model\UploadedAttachmentDTO';
        $request = $this->cloneAttachmentRequest($attachment_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloneAttachment'
     *
     * @param  string $attachment_uuid (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloneAttachmentRequest($attachment_uuid, $mailbox, string $contentType = self::contentTypes['cloneAttachment'][0])
    {

        // verify the required parameter 'attachment_uuid' is set
        if ($attachment_uuid === null || (is_array($attachment_uuid) && count($attachment_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_uuid when calling cloneAttachment'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling cloneAttachment'
            );
        }


        $resourcePath = '/api/v1/envelope/clone-attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_uuid,
            'attachmentUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation confirmInvite
     *
     * Accept/confirm invitations
     *
     * @param  \DocStudio\Client\Model\EnvelopeConfirmInviteDTO $envelope_confirm_invite_dto envelope_confirm_invite_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmInvite'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function confirmInvite($envelope_confirm_invite_dto, string $contentType = self::contentTypes['confirmInvite'][0])
    {
        $this->confirmInviteWithHttpInfo($envelope_confirm_invite_dto, $contentType);
    }

    /**
     * Operation confirmInviteWithHttpInfo
     *
     * Accept/confirm invitations
     *
     * @param  \DocStudio\Client\Model\EnvelopeConfirmInviteDTO $envelope_confirm_invite_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmInvite'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function confirmInviteWithHttpInfo($envelope_confirm_invite_dto, string $contentType = self::contentTypes['confirmInvite'][0])
    {
        $request = $this->confirmInviteRequest($envelope_confirm_invite_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation confirmInviteAsync
     *
     * Accept/confirm invitations
     *
     * @param  \DocStudio\Client\Model\EnvelopeConfirmInviteDTO $envelope_confirm_invite_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmInvite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmInviteAsync($envelope_confirm_invite_dto, string $contentType = self::contentTypes['confirmInvite'][0])
    {
        return $this->confirmInviteAsyncWithHttpInfo($envelope_confirm_invite_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmInviteAsyncWithHttpInfo
     *
     * Accept/confirm invitations
     *
     * @param  \DocStudio\Client\Model\EnvelopeConfirmInviteDTO $envelope_confirm_invite_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmInvite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmInviteAsyncWithHttpInfo($envelope_confirm_invite_dto, string $contentType = self::contentTypes['confirmInvite'][0])
    {
        $returnType = '';
        $request = $this->confirmInviteRequest($envelope_confirm_invite_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmInvite'
     *
     * @param  \DocStudio\Client\Model\EnvelopeConfirmInviteDTO $envelope_confirm_invite_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmInvite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function confirmInviteRequest($envelope_confirm_invite_dto, string $contentType = self::contentTypes['confirmInvite'][0])
    {

        // verify the required parameter 'envelope_confirm_invite_dto' is set
        if ($envelope_confirm_invite_dto === null || (is_array($envelope_confirm_invite_dto) && count($envelope_confirm_invite_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_confirm_invite_dto when calling confirmInvite'
            );
        }


        $resourcePath = '/api/v1/envelope/confirm-invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_confirm_invite_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_confirm_invite_dto));
            } else {
                $httpBody = $envelope_confirm_invite_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation continueScenarioStep
     *
     * Continue scenario flow with step
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $step_id Step id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['continueScenarioStep'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO[]
     */
    public function continueScenarioStep($envelope_uuid, $step_id, $mailbox, string $contentType = self::contentTypes['continueScenarioStep'][0])
    {
        list($response) = $this->continueScenarioStepWithHttpInfo($envelope_uuid, $step_id, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation continueScenarioStepWithHttpInfo
     *
     * Continue scenario flow with step
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $step_id Step id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['continueScenarioStep'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function continueScenarioStepWithHttpInfo($envelope_uuid, $step_id, $mailbox, string $contentType = self::contentTypes['continueScenarioStep'][0])
    {
        $request = $this->continueScenarioStepRequest($envelope_uuid, $step_id, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation continueScenarioStepAsync
     *
     * Continue scenario flow with step
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $step_id Step id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['continueScenarioStep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function continueScenarioStepAsync($envelope_uuid, $step_id, $mailbox, string $contentType = self::contentTypes['continueScenarioStep'][0])
    {
        return $this->continueScenarioStepAsyncWithHttpInfo($envelope_uuid, $step_id, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation continueScenarioStepAsyncWithHttpInfo
     *
     * Continue scenario flow with step
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $step_id Step id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['continueScenarioStep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function continueScenarioStepAsyncWithHttpInfo($envelope_uuid, $step_id, $mailbox, string $contentType = self::contentTypes['continueScenarioStep'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO[]';
        $request = $this->continueScenarioStepRequest($envelope_uuid, $step_id, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'continueScenarioStep'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $step_id Step id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['continueScenarioStep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function continueScenarioStepRequest($envelope_uuid, $step_id, $mailbox, string $contentType = self::contentTypes['continueScenarioStep'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling continueScenarioStep'
            );
        }

        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling continueScenarioStep'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling continueScenarioStep'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/scenario/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation create
     *
     * Create draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function create($mailbox, $env_post_dto, string $contentType = self::contentTypes['create'][0])
    {
        list($response) = $this->createWithHttpInfo($mailbox, $env_post_dto, $contentType);
        return $response;
    }

    /**
     * Operation createWithHttpInfo
     *
     * Create draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['create'][0])
    {
        $request = $this->createRequest($mailbox, $env_post_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAsync
     *
     * Create draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsync($mailbox, $env_post_dto, string $contentType = self::contentTypes['create'][0])
    {
        return $this->createAsyncWithHttpInfo($mailbox, $env_post_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAsyncWithHttpInfo
     *
     * Create draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsyncWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['create'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->createRequest($mailbox, $env_post_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'create'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRequest($mailbox, $env_post_dto, string $contentType = self::contentTypes['create'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling create'
            );
        }

        // verify the required parameter 'env_post_dto' is set
        if ($env_post_dto === null || (is_array($env_post_dto) && count($env_post_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_post_dto when calling create'
            );
        }


        $resourcePath = '/api/v1/envelope';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_post_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_post_dto));
            } else {
                $httpBody = $env_post_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAttachment
     *
     * Create/upload new attachment
     *
     * @param  \SplFileObject $file file (required)
     * @param  string|null $type type (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\UploadedAttachmentDTO
     */
    public function createAttachment($file, $type = null, $mailbox = null, string $contentType = self::contentTypes['createAttachment'][0])
    {
        list($response) = $this->createAttachmentWithHttpInfo($file, $type, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation createAttachmentWithHttpInfo
     *
     * Create/upload new attachment
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $type (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\UploadedAttachmentDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAttachmentWithHttpInfo($file, $type = null, $mailbox = null, string $contentType = self::contentTypes['createAttachment'][0])
    {
        $request = $this->createAttachmentRequest($file, $type, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\UploadedAttachmentDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\UploadedAttachmentDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\UploadedAttachmentDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\UploadedAttachmentDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\UploadedAttachmentDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAttachmentAsync
     *
     * Create/upload new attachment
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $type (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAttachmentAsync($file, $type = null, $mailbox = null, string $contentType = self::contentTypes['createAttachment'][0])
    {
        return $this->createAttachmentAsyncWithHttpInfo($file, $type, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAttachmentAsyncWithHttpInfo
     *
     * Create/upload new attachment
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $type (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAttachmentAsyncWithHttpInfo($file, $type = null, $mailbox = null, string $contentType = self::contentTypes['createAttachment'][0])
    {
        $returnType = '\DocStudio\Client\Model\UploadedAttachmentDTO';
        $request = $this->createAttachmentRequest($file, $type, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAttachment'
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $type (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAttachmentRequest($file, $type = null, $mailbox = null, string $contentType = self::contentTypes['createAttachment'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling createAttachment'
            );
        }




        $resourcePath = '/api/v1/envelope/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEnvelopeComment
     *
     * Create envelope comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPostDTO $comment_post_dto comment_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\CommentThreadDTO
     */
    public function createEnvelopeComment($envelope_uuid, $mailbox, $comment_post_dto, string $contentType = self::contentTypes['createEnvelopeComment'][0])
    {
        list($response) = $this->createEnvelopeCommentWithHttpInfo($envelope_uuid, $mailbox, $comment_post_dto, $contentType);
        return $response;
    }

    /**
     * Operation createEnvelopeCommentWithHttpInfo
     *
     * Create envelope comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPostDTO $comment_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\CommentThreadDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEnvelopeCommentWithHttpInfo($envelope_uuid, $mailbox, $comment_post_dto, string $contentType = self::contentTypes['createEnvelopeComment'][0])
    {
        $request = $this->createEnvelopeCommentRequest($envelope_uuid, $mailbox, $comment_post_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\CommentThreadDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\CommentThreadDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\CommentThreadDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\CommentThreadDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEnvelopeCommentAsync
     *
     * Create envelope comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPostDTO $comment_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEnvelopeCommentAsync($envelope_uuid, $mailbox, $comment_post_dto, string $contentType = self::contentTypes['createEnvelopeComment'][0])
    {
        return $this->createEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $mailbox, $comment_post_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEnvelopeCommentAsyncWithHttpInfo
     *
     * Create envelope comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPostDTO $comment_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $mailbox, $comment_post_dto, string $contentType = self::contentTypes['createEnvelopeComment'][0])
    {
        $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
        $request = $this->createEnvelopeCommentRequest($envelope_uuid, $mailbox, $comment_post_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEnvelopeComment'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPostDTO $comment_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEnvelopeCommentRequest($envelope_uuid, $mailbox, $comment_post_dto, string $contentType = self::contentTypes['createEnvelopeComment'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling createEnvelopeComment'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling createEnvelopeComment'
            );
        }

        // verify the required parameter 'comment_post_dto' is set
        if ($comment_post_dto === null || (is_array($comment_post_dto) && count($comment_post_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_post_dto when calling createEnvelopeComment'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_post_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($comment_post_dto));
            } else {
                $httpBody = $comment_post_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPdfAttachment
     *
     * Create/upload new PDF attachment
     *
     * @param  \SplFileObject $file file (required)
     * @param  string|null $action Action for fields inside the PDF file (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\UploadedAttachmentDTO
     */
    public function createPdfAttachment($file, $action = null, $mailbox = null, string $contentType = self::contentTypes['createPdfAttachment'][0])
    {
        list($response) = $this->createPdfAttachmentWithHttpInfo($file, $action, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation createPdfAttachmentWithHttpInfo
     *
     * Create/upload new PDF attachment
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $action Action for fields inside the PDF file (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\UploadedAttachmentDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPdfAttachmentWithHttpInfo($file, $action = null, $mailbox = null, string $contentType = self::contentTypes['createPdfAttachment'][0])
    {
        $request = $this->createPdfAttachmentRequest($file, $action, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\UploadedAttachmentDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\UploadedAttachmentDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\UploadedAttachmentDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\UploadedAttachmentDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\UploadedAttachmentDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPdfAttachmentAsync
     *
     * Create/upload new PDF attachment
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $action Action for fields inside the PDF file (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPdfAttachmentAsync($file, $action = null, $mailbox = null, string $contentType = self::contentTypes['createPdfAttachment'][0])
    {
        return $this->createPdfAttachmentAsyncWithHttpInfo($file, $action, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPdfAttachmentAsyncWithHttpInfo
     *
     * Create/upload new PDF attachment
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $action Action for fields inside the PDF file (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPdfAttachmentAsyncWithHttpInfo($file, $action = null, $mailbox = null, string $contentType = self::contentTypes['createPdfAttachment'][0])
    {
        $returnType = '\DocStudio\Client\Model\UploadedAttachmentDTO';
        $request = $this->createPdfAttachmentRequest($file, $action, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPdfAttachment'
     *
     * @param  \SplFileObject $file (required)
     * @param  string|null $action Action for fields inside the PDF file (optional)
     * @param  string|null $mailbox Mailbox context, HTTP Header with current mailbox UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPdfAttachmentRequest($file, $action = null, $mailbox = null, string $contentType = self::contentTypes['createPdfAttachment'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling createPdfAttachment'
            );
        }




        $resourcePath = '/api/v1/envelope/pdf-attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation delegateEnvelopes
     *
     * Delegate envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDelegationDTO $env_delegation_dto env_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delegateEnvelopes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function delegateEnvelopes($mailbox, $env_delegation_dto, string $contentType = self::contentTypes['delegateEnvelopes'][0])
    {
        list($response) = $this->delegateEnvelopesWithHttpInfo($mailbox, $env_delegation_dto, $contentType);
        return $response;
    }

    /**
     * Operation delegateEnvelopesWithHttpInfo
     *
     * Delegate envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDelegationDTO $env_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delegateEnvelopes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function delegateEnvelopesWithHttpInfo($mailbox, $env_delegation_dto, string $contentType = self::contentTypes['delegateEnvelopes'][0])
    {
        $request = $this->delegateEnvelopesRequest($mailbox, $env_delegation_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation delegateEnvelopesAsync
     *
     * Delegate envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDelegationDTO $env_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delegateEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function delegateEnvelopesAsync($mailbox, $env_delegation_dto, string $contentType = self::contentTypes['delegateEnvelopes'][0])
    {
        return $this->delegateEnvelopesAsyncWithHttpInfo($mailbox, $env_delegation_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation delegateEnvelopesAsyncWithHttpInfo
     *
     * Delegate envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDelegationDTO $env_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delegateEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function delegateEnvelopesAsyncWithHttpInfo($mailbox, $env_delegation_dto, string $contentType = self::contentTypes['delegateEnvelopes'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->delegateEnvelopesRequest($mailbox, $env_delegation_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'delegateEnvelopes'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvDelegationDTO $env_delegation_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delegateEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function delegateEnvelopesRequest($mailbox, $env_delegation_dto, string $contentType = self::contentTypes['delegateEnvelopes'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling delegateEnvelopes'
            );
        }

        // verify the required parameter 'env_delegation_dto' is set
        if ($env_delegation_dto === null || (is_array($env_delegation_dto) && count($env_delegation_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_delegation_dto when calling delegateEnvelopes'
            );
        }


        $resourcePath = '/api/v1/envelope/delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_delegation_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_delegation_dto));
            } else {
                $httpBody = $env_delegation_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDrafts
     *
     * Delete draft envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDrafts'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDrafts($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['deleteDrafts'][0])
    {
        $this->deleteDraftsWithHttpInfo($mailbox, $bulk_envelope_action_dto, $contentType);
    }

    /**
     * Operation deleteDraftsWithHttpInfo
     *
     * Delete draft envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDrafts'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDraftsWithHttpInfo($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['deleteDrafts'][0])
    {
        $request = $this->deleteDraftsRequest($mailbox, $bulk_envelope_action_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDraftsAsync
     *
     * Delete draft envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDrafts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDraftsAsync($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['deleteDrafts'][0])
    {
        return $this->deleteDraftsAsyncWithHttpInfo($mailbox, $bulk_envelope_action_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDraftsAsyncWithHttpInfo
     *
     * Delete draft envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDrafts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDraftsAsyncWithHttpInfo($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['deleteDrafts'][0])
    {
        $returnType = '';
        $request = $this->deleteDraftsRequest($mailbox, $bulk_envelope_action_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDrafts'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDrafts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDraftsRequest($mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['deleteDrafts'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling deleteDrafts'
            );
        }

        // verify the required parameter 'bulk_envelope_action_dto' is set
        if ($bulk_envelope_action_dto === null || (is_array($bulk_envelope_action_dto) && count($bulk_envelope_action_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_envelope_action_dto when calling deleteDrafts'
            );
        }


        $resourcePath = '/api/v1/envelope';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_envelope_action_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_envelope_action_dto));
            } else {
                $httpBody = $bulk_envelope_action_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEnvelopeComment
     *
     * Delete envelope comment in thread or the whole thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $thread_uuid Thread UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  int|null $message_id Message ID (optional) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\CommentThreadDTO
     */
    public function deleteEnvelopeComment($envelope_uuid, $thread_uuid, $mailbox, $message_id = null, string $contentType = self::contentTypes['deleteEnvelopeComment'][0])
    {
        list($response) = $this->deleteEnvelopeCommentWithHttpInfo($envelope_uuid, $thread_uuid, $mailbox, $message_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteEnvelopeCommentWithHttpInfo
     *
     * Delete envelope comment in thread or the whole thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $thread_uuid Thread UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  int|null $message_id Message ID (optional) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\CommentThreadDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEnvelopeCommentWithHttpInfo($envelope_uuid, $thread_uuid, $mailbox, $message_id = null, string $contentType = self::contentTypes['deleteEnvelopeComment'][0])
    {
        $request = $this->deleteEnvelopeCommentRequest($envelope_uuid, $thread_uuid, $mailbox, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\CommentThreadDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\CommentThreadDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\CommentThreadDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\CommentThreadDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteEnvelopeCommentAsync
     *
     * Delete envelope comment in thread or the whole thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $thread_uuid Thread UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  int|null $message_id Message ID (optional) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEnvelopeCommentAsync($envelope_uuid, $thread_uuid, $mailbox, $message_id = null, string $contentType = self::contentTypes['deleteEnvelopeComment'][0])
    {
        return $this->deleteEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $thread_uuid, $mailbox, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEnvelopeCommentAsyncWithHttpInfo
     *
     * Delete envelope comment in thread or the whole thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $thread_uuid Thread UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  int|null $message_id Message ID (optional) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $thread_uuid, $mailbox, $message_id = null, string $contentType = self::contentTypes['deleteEnvelopeComment'][0])
    {
        $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
        $request = $this->deleteEnvelopeCommentRequest($envelope_uuid, $thread_uuid, $mailbox, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEnvelopeComment'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $thread_uuid Thread UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  int|null $message_id Message ID (optional) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteEnvelopeCommentRequest($envelope_uuid, $thread_uuid, $mailbox, $message_id = null, string $contentType = self::contentTypes['deleteEnvelopeComment'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling deleteEnvelopeComment'
            );
        }

        // verify the required parameter 'thread_uuid' is set
        if ($thread_uuid === null || (is_array($thread_uuid) && count($thread_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $thread_uuid when calling deleteEnvelopeComment'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling deleteEnvelopeComment'
            );
        }



        $resourcePath = '/api/v1/envelope/{envelopeUuid}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_uuid,
            'threadUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message_id,
            'messageId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadEnvelopeAttachment
     *
     * Download attachment with specific type or raw
     *
     * @param  string $accept accept (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadEnvelopeAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadEnvelopeAttachment($accept, $attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['downloadEnvelopeAttachment'][0])
    {
        list($response) = $this->downloadEnvelopeAttachmentWithHttpInfo($accept, $attachment_uuid, $mailbox, $envelope_uuid, $contentType);
        return $response;
    }

    /**
     * Operation downloadEnvelopeAttachmentWithHttpInfo
     *
     * Download attachment with specific type or raw
     *
     * @param  string $accept (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadEnvelopeAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadEnvelopeAttachmentWithHttpInfo($accept, $attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['downloadEnvelopeAttachment'][0])
    {
        $request = $this->downloadEnvelopeAttachmentRequest($accept, $attachment_uuid, $mailbox, $envelope_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadEnvelopeAttachmentAsync
     *
     * Download attachment with specific type or raw
     *
     * @param  string $accept (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadEnvelopeAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadEnvelopeAttachmentAsync($accept, $attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['downloadEnvelopeAttachment'][0])
    {
        return $this->downloadEnvelopeAttachmentAsyncWithHttpInfo($accept, $attachment_uuid, $mailbox, $envelope_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadEnvelopeAttachmentAsyncWithHttpInfo
     *
     * Download attachment with specific type or raw
     *
     * @param  string $accept (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadEnvelopeAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadEnvelopeAttachmentAsyncWithHttpInfo($accept, $attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['downloadEnvelopeAttachment'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadEnvelopeAttachmentRequest($accept, $attachment_uuid, $mailbox, $envelope_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadEnvelopeAttachment'
     *
     * @param  string $accept (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadEnvelopeAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadEnvelopeAttachmentRequest($accept, $attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['downloadEnvelopeAttachment'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling downloadEnvelopeAttachment'
            );
        }

        // verify the required parameter 'attachment_uuid' is set
        if ($attachment_uuid === null || (is_array($attachment_uuid) && count($attachment_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_uuid when calling downloadEnvelopeAttachment'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling downloadEnvelopeAttachment'
            );
        }



        $resourcePath = '/api/v1/envelope/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $envelope_uuid,
            'envelopeUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_uuid,
            'attachmentUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFinalPdf
     *
     * Download final PDF
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFinalPdf'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadFinalPdf($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['downloadFinalPdf'][0])
    {
        list($response) = $this->downloadFinalPdfWithHttpInfo($envelope_uuid, $document_id, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation downloadFinalPdfWithHttpInfo
     *
     * Download final PDF
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFinalPdf'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFinalPdfWithHttpInfo($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['downloadFinalPdf'][0])
    {
        $request = $this->downloadFinalPdfRequest($envelope_uuid, $document_id, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFinalPdfAsync
     *
     * Download final PDF
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFinalPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFinalPdfAsync($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['downloadFinalPdf'][0])
    {
        return $this->downloadFinalPdfAsyncWithHttpInfo($envelope_uuid, $document_id, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFinalPdfAsyncWithHttpInfo
     *
     * Download final PDF
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFinalPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFinalPdfAsyncWithHttpInfo($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['downloadFinalPdf'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadFinalPdfRequest($envelope_uuid, $document_id, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFinalPdf'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFinalPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadFinalPdfRequest($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['downloadFinalPdf'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling downloadFinalPdf'
            );
        }

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling downloadFinalPdf'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling downloadFinalPdf'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/download-final-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadSharedAttachment
     *
     * Download shared attachment for specific provider
     *
     * @param  string $provider Sharing provider name (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadSharedAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadSharedAttachment($provider, $attachment_uuid, string $contentType = self::contentTypes['downloadSharedAttachment'][0])
    {
        list($response) = $this->downloadSharedAttachmentWithHttpInfo($provider, $attachment_uuid, $contentType);
        return $response;
    }

    /**
     * Operation downloadSharedAttachmentWithHttpInfo
     *
     * Download shared attachment for specific provider
     *
     * @param  string $provider Sharing provider name (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadSharedAttachment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadSharedAttachmentWithHttpInfo($provider, $attachment_uuid, string $contentType = self::contentTypes['downloadSharedAttachment'][0])
    {
        $request = $this->downloadSharedAttachmentRequest($provider, $attachment_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadSharedAttachmentAsync
     *
     * Download shared attachment for specific provider
     *
     * @param  string $provider Sharing provider name (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadSharedAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadSharedAttachmentAsync($provider, $attachment_uuid, string $contentType = self::contentTypes['downloadSharedAttachment'][0])
    {
        return $this->downloadSharedAttachmentAsyncWithHttpInfo($provider, $attachment_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadSharedAttachmentAsyncWithHttpInfo
     *
     * Download shared attachment for specific provider
     *
     * @param  string $provider Sharing provider name (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadSharedAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadSharedAttachmentAsyncWithHttpInfo($provider, $attachment_uuid, string $contentType = self::contentTypes['downloadSharedAttachment'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadSharedAttachmentRequest($provider, $attachment_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadSharedAttachment'
     *
     * @param  string $provider Sharing provider name (required)
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadSharedAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadSharedAttachmentRequest($provider, $attachment_uuid, string $contentType = self::contentTypes['downloadSharedAttachment'][0])
    {

        // verify the required parameter 'provider' is set
        if ($provider === null || (is_array($provider) && count($provider) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider when calling downloadSharedAttachment'
            );
        }

        // verify the required parameter 'attachment_uuid' is set
        if ($attachment_uuid === null || (is_array($attachment_uuid) && count($attachment_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_uuid when calling downloadSharedAttachment'
            );
        }


        $resourcePath = '/api/v1/envelope/shared-attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_uuid,
            'attachmentUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation envelopeApproval
     *
     * Approve or Reject envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ApprovalStatusDTO $approval_status_dto approval_status_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApproval'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function envelopeApproval($mailbox, $approval_status_dto, string $contentType = self::contentTypes['envelopeApproval'][0])
    {
        $this->envelopeApprovalWithHttpInfo($mailbox, $approval_status_dto, $contentType);
    }

    /**
     * Operation envelopeApprovalWithHttpInfo
     *
     * Approve or Reject envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ApprovalStatusDTO $approval_status_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApproval'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function envelopeApprovalWithHttpInfo($mailbox, $approval_status_dto, string $contentType = self::contentTypes['envelopeApproval'][0])
    {
        $request = $this->envelopeApprovalRequest($mailbox, $approval_status_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation envelopeApprovalAsync
     *
     * Approve or Reject envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ApprovalStatusDTO $approval_status_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function envelopeApprovalAsync($mailbox, $approval_status_dto, string $contentType = self::contentTypes['envelopeApproval'][0])
    {
        return $this->envelopeApprovalAsyncWithHttpInfo($mailbox, $approval_status_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation envelopeApprovalAsyncWithHttpInfo
     *
     * Approve or Reject envelopes
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ApprovalStatusDTO $approval_status_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function envelopeApprovalAsyncWithHttpInfo($mailbox, $approval_status_dto, string $contentType = self::contentTypes['envelopeApproval'][0])
    {
        $returnType = '';
        $request = $this->envelopeApprovalRequest($mailbox, $approval_status_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'envelopeApproval'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ApprovalStatusDTO $approval_status_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function envelopeApprovalRequest($mailbox, $approval_status_dto, string $contentType = self::contentTypes['envelopeApproval'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling envelopeApproval'
            );
        }

        // verify the required parameter 'approval_status_dto' is set
        if ($approval_status_dto === null || (is_array($approval_status_dto) && count($approval_status_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_status_dto when calling envelopeApproval'
            );
        }


        $resourcePath = '/api/v1/envelope/approval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($approval_status_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($approval_status_dto));
            } else {
                $httpBody = $approval_status_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation envelopeApprovalHistory
     *
     * Get approval history
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApprovalHistory'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]
     */
    public function envelopeApprovalHistory($envelope_uuid, $mailbox, string $contentType = self::contentTypes['envelopeApprovalHistory'][0])
    {
        list($response) = $this->envelopeApprovalHistoryWithHttpInfo($envelope_uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation envelopeApprovalHistoryWithHttpInfo
     *
     * Get approval history
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApprovalHistory'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function envelopeApprovalHistoryWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['envelopeApprovalHistory'][0])
    {
        $request = $this->envelopeApprovalHistoryRequest($envelope_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation envelopeApprovalHistoryAsync
     *
     * Get approval history
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApprovalHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function envelopeApprovalHistoryAsync($envelope_uuid, $mailbox, string $contentType = self::contentTypes['envelopeApprovalHistory'][0])
    {
        return $this->envelopeApprovalHistoryAsyncWithHttpInfo($envelope_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation envelopeApprovalHistoryAsyncWithHttpInfo
     *
     * Get approval history
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApprovalHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function envelopeApprovalHistoryAsyncWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['envelopeApprovalHistory'][0])
    {
        $returnType = '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO[]';
        $request = $this->envelopeApprovalHistoryRequest($envelope_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'envelopeApprovalHistory'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['envelopeApprovalHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function envelopeApprovalHistoryRequest($envelope_uuid, $mailbox, string $contentType = self::contentTypes['envelopeApprovalHistory'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling envelopeApprovalHistory'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling envelopeApprovalHistory'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/approval-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fill
     *
     * Fill envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fill'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function fill($mailbox, $env_post_dto, string $contentType = self::contentTypes['fill'][0])
    {
        $this->fillWithHttpInfo($mailbox, $env_post_dto, $contentType);
    }

    /**
     * Operation fillWithHttpInfo
     *
     * Fill envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fill'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function fillWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['fill'][0])
    {
        $request = $this->fillRequest($mailbox, $env_post_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation fillAsync
     *
     * Fill envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fill'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fillAsync($mailbox, $env_post_dto, string $contentType = self::contentTypes['fill'][0])
    {
        return $this->fillAsyncWithHttpInfo($mailbox, $env_post_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fillAsyncWithHttpInfo
     *
     * Fill envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fill'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fillAsyncWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['fill'][0])
    {
        $returnType = '';
        $request = $this->fillRequest($mailbox, $env_post_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fill'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fill'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fillRequest($mailbox, $env_post_dto, string $contentType = self::contentTypes['fill'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling fill'
            );
        }

        // verify the required parameter 'env_post_dto' is set
        if ($env_post_dto === null || (is_array($env_post_dto) && count($env_post_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_post_dto when calling fill'
            );
        }


        $resourcePath = '/api/v1/envelope/fill';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_post_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_post_dto));
            } else {
                $httpBody = $env_post_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateStamp
     *
     * Generate stamp by certificate
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\StampRequestDTO $stamp_request_dto stamp_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateStamp'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function generateStamp($mailbox, $stamp_request_dto, string $contentType = self::contentTypes['generateStamp'][0])
    {
        list($response) = $this->generateStampWithHttpInfo($mailbox, $stamp_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation generateStampWithHttpInfo
     *
     * Generate stamp by certificate
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\StampRequestDTO $stamp_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateStamp'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateStampWithHttpInfo($mailbox, $stamp_request_dto, string $contentType = self::contentTypes['generateStamp'][0])
    {
        $request = $this->generateStampRequest($mailbox, $stamp_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateStampAsync
     *
     * Generate stamp by certificate
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\StampRequestDTO $stamp_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateStamp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateStampAsync($mailbox, $stamp_request_dto, string $contentType = self::contentTypes['generateStamp'][0])
    {
        return $this->generateStampAsyncWithHttpInfo($mailbox, $stamp_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateStampAsyncWithHttpInfo
     *
     * Generate stamp by certificate
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\StampRequestDTO $stamp_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateStamp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateStampAsyncWithHttpInfo($mailbox, $stamp_request_dto, string $contentType = self::contentTypes['generateStamp'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->generateStampRequest($mailbox, $stamp_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateStamp'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\StampRequestDTO $stamp_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateStamp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateStampRequest($mailbox, $stamp_request_dto, string $contentType = self::contentTypes['generateStamp'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling generateStamp'
            );
        }

        // verify the required parameter 'stamp_request_dto' is set
        if ($stamp_request_dto === null || (is_array($stamp_request_dto) && count($stamp_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp_request_dto when calling generateStamp'
            );
        }


        $resourcePath = '/api/v1/envelope/generate-stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['image/png', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($stamp_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($stamp_request_dto));
            } else {
                $httpBody = $stamp_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActiveRoles
     *
     * Get active roles by Envelope UUID
     *
     * @param  string $uuid UUID of envelope to get active roles from (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveRoles'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO[]
     */
    public function getActiveRoles($uuid, $mailbox, string $contentType = self::contentTypes['getActiveRoles'][0])
    {
        list($response) = $this->getActiveRolesWithHttpInfo($uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getActiveRolesWithHttpInfo
     *
     * Get active roles by Envelope UUID
     *
     * @param  string $uuid UUID of envelope to get active roles from (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveRoles'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getActiveRolesWithHttpInfo($uuid, $mailbox, string $contentType = self::contentTypes['getActiveRoles'][0])
    {
        $request = $this->getActiveRolesRequest($uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActiveRolesAsync
     *
     * Get active roles by Envelope UUID
     *
     * @param  string $uuid UUID of envelope to get active roles from (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActiveRolesAsync($uuid, $mailbox, string $contentType = self::contentTypes['getActiveRoles'][0])
    {
        return $this->getActiveRolesAsyncWithHttpInfo($uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActiveRolesAsyncWithHttpInfo
     *
     * Get active roles by Envelope UUID
     *
     * @param  string $uuid UUID of envelope to get active roles from (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActiveRolesAsyncWithHttpInfo($uuid, $mailbox, string $contentType = self::contentTypes['getActiveRoles'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO[]';
        $request = $this->getActiveRolesRequest($uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActiveRoles'
     *
     * @param  string $uuid UUID of envelope to get active roles from (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getActiveRolesRequest($uuid, $mailbox, string $contentType = self::contentTypes['getActiveRoles'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling getActiveRoles'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getActiveRoles'
            );
        }


        $resourcePath = '/api/v1/envelope/{uuid}/activeRoles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApprovalFlow
     *
     * Get envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovalFlow'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\EnvelopeApprovalHistoryDTO
     */
    public function getApprovalFlow($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['getApprovalFlow'][0])
    {
        list($response) = $this->getApprovalFlowWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getApprovalFlowWithHttpInfo
     *
     * Get envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovalFlow'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\EnvelopeApprovalHistoryDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApprovalFlowWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['getApprovalFlow'][0])
    {
        $request = $this->getApprovalFlowRequest($envelope_uuid, $flow_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApprovalFlowAsync
     *
     * Get envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovalFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovalFlowAsync($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['getApprovalFlow'][0])
    {
        return $this->getApprovalFlowAsyncWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApprovalFlowAsyncWithHttpInfo
     *
     * Get envelope approval
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovalFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovalFlowAsyncWithHttpInfo($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['getApprovalFlow'][0])
    {
        $returnType = '\DocStudio\Client\Model\EnvelopeApprovalHistoryDTO';
        $request = $this->getApprovalFlowRequest($envelope_uuid, $flow_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApprovalFlow'
     *
     * @param  string $envelope_uuid Envelope to approve (required)
     * @param  string $flow_uuid Flow to approve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovalFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApprovalFlowRequest($envelope_uuid, $flow_uuid, $mailbox, string $contentType = self::contentTypes['getApprovalFlow'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getApprovalFlow'
            );
        }

        // verify the required parameter 'flow_uuid' is set
        if ($flow_uuid === null || (is_array($flow_uuid) && count($flow_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_uuid when calling getApprovalFlow'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getApprovalFlow'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/approval/{flowUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }
        // path params
        if ($flow_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'flowUuid' . '}',
                ObjectSerializer::toPathValue($flow_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttachmentPageSizes
     *
     * Get attachment page sizes
     *
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachmentPageSizes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\PdfPageSizes
     */
    public function getAttachmentPageSizes($attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['getAttachmentPageSizes'][0])
    {
        list($response) = $this->getAttachmentPageSizesWithHttpInfo($attachment_uuid, $mailbox, $envelope_uuid, $contentType);
        return $response;
    }

    /**
     * Operation getAttachmentPageSizesWithHttpInfo
     *
     * Get attachment page sizes
     *
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachmentPageSizes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\PdfPageSizes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttachmentPageSizesWithHttpInfo($attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['getAttachmentPageSizes'][0])
    {
        $request = $this->getAttachmentPageSizesRequest($attachment_uuid, $mailbox, $envelope_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\PdfPageSizes' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\PdfPageSizes' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\PdfPageSizes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\PdfPageSizes';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\PdfPageSizes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttachmentPageSizesAsync
     *
     * Get attachment page sizes
     *
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachmentPageSizes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentPageSizesAsync($attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['getAttachmentPageSizes'][0])
    {
        return $this->getAttachmentPageSizesAsyncWithHttpInfo($attachment_uuid, $mailbox, $envelope_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttachmentPageSizesAsyncWithHttpInfo
     *
     * Get attachment page sizes
     *
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachmentPageSizes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentPageSizesAsyncWithHttpInfo($attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['getAttachmentPageSizes'][0])
    {
        $returnType = '\DocStudio\Client\Model\PdfPageSizes';
        $request = $this->getAttachmentPageSizesRequest($attachment_uuid, $mailbox, $envelope_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttachmentPageSizes'
     *
     * @param  string $attachment_uuid Attachment UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $envelope_uuid Envelope UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachmentPageSizes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAttachmentPageSizesRequest($attachment_uuid, $mailbox, $envelope_uuid = null, string $contentType = self::contentTypes['getAttachmentPageSizes'][0])
    {

        // verify the required parameter 'attachment_uuid' is set
        if ($attachment_uuid === null || (is_array($attachment_uuid) && count($attachment_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_uuid when calling getAttachmentPageSizes'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getAttachmentPageSizes'
            );
        }



        $resourcePath = '/api/v1/envelope/attachment/page-sizes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $envelope_uuid,
            'envelopeUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_uuid,
            'attachmentUuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChainEnvelopes
     *
     * Get chain envelopes list
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainEnvelopes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\ChainEnvelopeDTO[]
     */
    public function getChainEnvelopes($chain_uuid, $mailbox, string $contentType = self::contentTypes['getChainEnvelopes'][0])
    {
        list($response) = $this->getChainEnvelopesWithHttpInfo($chain_uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getChainEnvelopesWithHttpInfo
     *
     * Get chain envelopes list
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainEnvelopes'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\ChainEnvelopeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getChainEnvelopesWithHttpInfo($chain_uuid, $mailbox, string $contentType = self::contentTypes['getChainEnvelopes'][0])
    {
        $request = $this->getChainEnvelopesRequest($chain_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\ChainEnvelopeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\ChainEnvelopeDTO[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\ChainEnvelopeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\ChainEnvelopeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\ChainEnvelopeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChainEnvelopesAsync
     *
     * Get chain envelopes list
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChainEnvelopesAsync($chain_uuid, $mailbox, string $contentType = self::contentTypes['getChainEnvelopes'][0])
    {
        return $this->getChainEnvelopesAsyncWithHttpInfo($chain_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChainEnvelopesAsyncWithHttpInfo
     *
     * Get chain envelopes list
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChainEnvelopesAsyncWithHttpInfo($chain_uuid, $mailbox, string $contentType = self::contentTypes['getChainEnvelopes'][0])
    {
        $returnType = '\DocStudio\Client\Model\ChainEnvelopeDTO[]';
        $request = $this->getChainEnvelopesRequest($chain_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChainEnvelopes'
     *
     * @param  string $chain_uuid Chain UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainEnvelopes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChainEnvelopesRequest($chain_uuid, $mailbox, string $contentType = self::contentTypes['getChainEnvelopes'][0])
    {

        // verify the required parameter 'chain_uuid' is set
        if ($chain_uuid === null || (is_array($chain_uuid) && count($chain_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chain_uuid when calling getChainEnvelopes'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getChainEnvelopes'
            );
        }


        $resourcePath = '/api/v1/envelope/chain/{chainUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($chain_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'chainUuid' . '}',
                ObjectSerializer::toPathValue($chain_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentFileForSign
     *
     * Get BINARY or XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentFileForSignRequestDTO $document_file_for_sign_request_dto document_file_for_sign_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentFileForSign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentFileForSign($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, string $contentType = self::contentTypes['getDocumentFileForSign'][0])
    {
        list($response) = $this->getDocumentFileForSignWithHttpInfo($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentFileForSignWithHttpInfo
     *
     * Get BINARY or XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentFileForSignRequestDTO $document_file_for_sign_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentFileForSign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentFileForSignWithHttpInfo($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, string $contentType = self::contentTypes['getDocumentFileForSign'][0])
    {
        $request = $this->getDocumentFileForSignRequest($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentFileForSignAsync
     *
     * Get BINARY or XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentFileForSignRequestDTO $document_file_for_sign_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentFileForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFileForSignAsync($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, string $contentType = self::contentTypes['getDocumentFileForSign'][0])
    {
        return $this->getDocumentFileForSignAsyncWithHttpInfo($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentFileForSignAsyncWithHttpInfo
     *
     * Get BINARY or XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentFileForSignRequestDTO $document_file_for_sign_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentFileForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFileForSignAsyncWithHttpInfo($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, string $contentType = self::contentTypes['getDocumentFileForSign'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentFileForSignRequest($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentFileForSign'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentFileForSignRequestDTO $document_file_for_sign_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentFileForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentFileForSignRequest($envelope_uuid, $mailbox, $document_file_for_sign_request_dto, string $contentType = self::contentTypes['getDocumentFileForSign'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getDocumentFileForSign'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getDocumentFileForSign'
            );
        }

        // verify the required parameter 'document_file_for_sign_request_dto' is set
        if ($document_file_for_sign_request_dto === null || (is_array($document_file_for_sign_request_dto) && count($document_file_for_sign_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_file_for_sign_request_dto when calling getDocumentFileForSign'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/for-sign-file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($document_file_for_sign_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($document_file_for_sign_request_dto));
            } else {
                $httpBody = $document_file_for_sign_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentForSign
     *
     * BINARY and XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\SingleDocForSignRequestDTO $single_doc_for_sign_request_dto single_doc_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentForSign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\DocumentForSigningDTO
     */
    public function getDocumentForSign($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentForSign'][0])
    {
        list($response) = $this->getDocumentForSignWithHttpInfo($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentForSignWithHttpInfo
     *
     * BINARY and XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\SingleDocForSignRequestDTO $single_doc_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentForSign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\DocumentForSigningDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentForSignWithHttpInfo($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentForSign'][0])
    {
        $request = $this->getDocumentForSignRequest($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\DocumentForSigningDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\DocumentForSigningDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\DocumentForSigningDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\DocumentForSigningDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\DocumentForSigningDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentForSignAsync
     *
     * BINARY and XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\SingleDocForSignRequestDTO $single_doc_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentForSignAsync($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentForSign'][0])
    {
        return $this->getDocumentForSignAsyncWithHttpInfo($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentForSignAsyncWithHttpInfo
     *
     * BINARY and XML for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\SingleDocForSignRequestDTO $single_doc_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentForSignAsyncWithHttpInfo($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentForSign'][0])
    {
        $returnType = '\DocStudio\Client\Model\DocumentForSigningDTO';
        $request = $this->getDocumentForSignRequest($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentForSign'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\SingleDocForSignRequestDTO $single_doc_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentForSignRequest($envelope_uuid, $mailbox, $single_doc_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentForSign'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getDocumentForSign'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getDocumentForSign'
            );
        }

        // verify the required parameter 'single_doc_for_sign_request_dto' is set
        if ($single_doc_for_sign_request_dto === null || (is_array($single_doc_for_sign_request_dto) && count($single_doc_for_sign_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $single_doc_for_sign_request_dto when calling getDocumentForSign'
            );
        }



        $resourcePath = '/api/v1/envelope/{envelopeUuid}/for-single-sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $session_id,
            'sessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($single_doc_for_sign_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($single_doc_for_sign_request_dto));
            } else {
                $httpBody = $single_doc_for_sign_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPrintVersion
     *
     * Get document PDF for printing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentPrintVersion'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentPrintVersion($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['getDocumentPrintVersion'][0])
    {
        list($response) = $this->getDocumentPrintVersionWithHttpInfo($envelope_uuid, $document_id, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentPrintVersionWithHttpInfo
     *
     * Get document PDF for printing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentPrintVersion'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPrintVersionWithHttpInfo($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['getDocumentPrintVersion'][0])
    {
        $request = $this->getDocumentPrintVersionRequest($envelope_uuid, $document_id, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPrintVersionAsync
     *
     * Get document PDF for printing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentPrintVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPrintVersionAsync($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['getDocumentPrintVersion'][0])
    {
        return $this->getDocumentPrintVersionAsyncWithHttpInfo($envelope_uuid, $document_id, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPrintVersionAsyncWithHttpInfo
     *
     * Get document PDF for printing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentPrintVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPrintVersionAsyncWithHttpInfo($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['getDocumentPrintVersion'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentPrintVersionRequest($envelope_uuid, $document_id, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPrintVersion'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $document_id Document id (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentPrintVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentPrintVersionRequest($envelope_uuid, $document_id, $mailbox, string $contentType = self::contentTypes['getDocumentPrintVersion'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getDocumentPrintVersion'
            );
        }

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentPrintVersion'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getDocumentPrintVersion'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/for-print';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentsForSign
     *
     * BINARYs and XMLs for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentsForSignRequestDTO $documents_for_sign_request_dto documents_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentsForSign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\DocumentForSigningDTO[]
     */
    public function getDocumentsForSign($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentsForSign'][0])
    {
        list($response) = $this->getDocumentsForSignWithHttpInfo($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentsForSignWithHttpInfo
     *
     * BINARYs and XMLs for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentsForSignRequestDTO $documents_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentsForSign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\DocumentForSigningDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentsForSignWithHttpInfo($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentsForSign'][0])
    {
        $request = $this->getDocumentsForSignRequest($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\DocumentForSigningDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\DocumentForSigningDTO[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\DocumentForSigningDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\DocumentForSigningDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\DocumentForSigningDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentsForSignAsync
     *
     * BINARYs and XMLs for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentsForSignRequestDTO $documents_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentsForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentsForSignAsync($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentsForSign'][0])
    {
        return $this->getDocumentsForSignAsyncWithHttpInfo($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentsForSignAsyncWithHttpInfo
     *
     * BINARYs and XMLs for signing
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentsForSignRequestDTO $documents_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentsForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentsForSignAsyncWithHttpInfo($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentsForSign'][0])
    {
        $returnType = '\DocStudio\Client\Model\DocumentForSigningDTO[]';
        $request = $this->getDocumentsForSignRequest($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentsForSign'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\DocumentsForSignRequestDTO $documents_for_sign_request_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentsForSign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentsForSignRequest($envelope_uuid, $mailbox, $documents_for_sign_request_dto, $session_id = null, string $contentType = self::contentTypes['getDocumentsForSign'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getDocumentsForSign'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getDocumentsForSign'
            );
        }

        // verify the required parameter 'documents_for_sign_request_dto' is set
        if ($documents_for_sign_request_dto === null || (is_array($documents_for_sign_request_dto) && count($documents_for_sign_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documents_for_sign_request_dto when calling getDocumentsForSign'
            );
        }



        $resourcePath = '/api/v1/envelope/{envelopeUuid}/for-sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $session_id,
            'sessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($documents_for_sign_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($documents_for_sign_request_dto));
            } else {
                $httpBody = $documents_for_sign_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvelopeByUuid
     *
     * Retrieve envelope by UUID
     *
     * @param  string $envelope_uuid UUID of envelope to retrieve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeByUuid'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\EnvelopeWithTemplateDTO
     */
    public function getEnvelopeByUuid($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeByUuid'][0])
    {
        list($response) = $this->getEnvelopeByUuidWithHttpInfo($envelope_uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getEnvelopeByUuidWithHttpInfo
     *
     * Retrieve envelope by UUID
     *
     * @param  string $envelope_uuid UUID of envelope to retrieve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeByUuid'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\EnvelopeWithTemplateDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopeByUuidWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeByUuid'][0])
    {
        $request = $this->getEnvelopeByUuidRequest($envelope_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\EnvelopeWithTemplateDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\EnvelopeWithTemplateDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\EnvelopeWithTemplateDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\EnvelopeWithTemplateDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\EnvelopeWithTemplateDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvelopeByUuidAsync
     *
     * Retrieve envelope by UUID
     *
     * @param  string $envelope_uuid UUID of envelope to retrieve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeByUuidAsync($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeByUuid'][0])
    {
        return $this->getEnvelopeByUuidAsyncWithHttpInfo($envelope_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvelopeByUuidAsyncWithHttpInfo
     *
     * Retrieve envelope by UUID
     *
     * @param  string $envelope_uuid UUID of envelope to retrieve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeByUuidAsyncWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeByUuid'][0])
    {
        $returnType = '\DocStudio\Client\Model\EnvelopeWithTemplateDTO';
        $request = $this->getEnvelopeByUuidRequest($envelope_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvelopeByUuid'
     *
     * @param  string $envelope_uuid UUID of envelope to retrieve (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEnvelopeByUuidRequest($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeByUuid'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getEnvelopeByUuid'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getEnvelopeByUuid'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvelopeComments
     *
     * Get envelope comments for each document
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeComments'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\DocumentCommentsDTO[]
     */
    public function getEnvelopeComments($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeComments'][0])
    {
        list($response) = $this->getEnvelopeCommentsWithHttpInfo($envelope_uuid, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getEnvelopeCommentsWithHttpInfo
     *
     * Get envelope comments for each document
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeComments'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\DocumentCommentsDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopeCommentsWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeComments'][0])
    {
        $request = $this->getEnvelopeCommentsRequest($envelope_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\DocumentCommentsDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\DocumentCommentsDTO[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\DocumentCommentsDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\DocumentCommentsDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\DocumentCommentsDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvelopeCommentsAsync
     *
     * Get envelope comments for each document
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeCommentsAsync($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeComments'][0])
    {
        return $this->getEnvelopeCommentsAsyncWithHttpInfo($envelope_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvelopeCommentsAsyncWithHttpInfo
     *
     * Get envelope comments for each document
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeCommentsAsyncWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeComments'][0])
    {
        $returnType = '\DocStudio\Client\Model\DocumentCommentsDTO[]';
        $request = $this->getEnvelopeCommentsRequest($envelope_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvelopeComments'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEnvelopeCommentsRequest($envelope_uuid, $mailbox, string $contentType = self::contentTypes['getEnvelopeComments'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getEnvelopeComments'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getEnvelopeComments'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvelopeInviteAuthorized
     *
     * Get information about envelope by the invitation code (by already registered user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteAuthorized'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\InvitedEnvelopeInfoDTO
     */
    public function getEnvelopeInviteAuthorized($code, string $contentType = self::contentTypes['getEnvelopeInviteAuthorized'][0])
    {
        list($response) = $this->getEnvelopeInviteAuthorizedWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation getEnvelopeInviteAuthorizedWithHttpInfo
     *
     * Get information about envelope by the invitation code (by already registered user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteAuthorized'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\InvitedEnvelopeInfoDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopeInviteAuthorizedWithHttpInfo($code, string $contentType = self::contentTypes['getEnvelopeInviteAuthorized'][0])
    {
        $request = $this->getEnvelopeInviteAuthorizedRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\InvitedEnvelopeInfoDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\InvitedEnvelopeInfoDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvelopeInviteAuthorizedAsync
     *
     * Get information about envelope by the invitation code (by already registered user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteAuthorized'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeInviteAuthorizedAsync($code, string $contentType = self::contentTypes['getEnvelopeInviteAuthorized'][0])
    {
        return $this->getEnvelopeInviteAuthorizedAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvelopeInviteAuthorizedAsyncWithHttpInfo
     *
     * Get information about envelope by the invitation code (by already registered user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteAuthorized'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeInviteAuthorizedAsyncWithHttpInfo($code, string $contentType = self::contentTypes['getEnvelopeInviteAuthorized'][0])
    {
        $returnType = '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO';
        $request = $this->getEnvelopeInviteAuthorizedRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvelopeInviteAuthorized'
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteAuthorized'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEnvelopeInviteAuthorizedRequest($code, string $contentType = self::contentTypes['getEnvelopeInviteAuthorized'][0])
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling getEnvelopeInviteAuthorized'
            );
        }


        $resourcePath = '/api/v1/envelope/invite-authorized-info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvelopeInviteUnauthorized
     *
     * Get information about envelope by the invitation code (by unauthenticated user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteUnauthorized'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\InvitedEnvelopeInfoDTO
     */
    public function getEnvelopeInviteUnauthorized($code, string $contentType = self::contentTypes['getEnvelopeInviteUnauthorized'][0])
    {
        list($response) = $this->getEnvelopeInviteUnauthorizedWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation getEnvelopeInviteUnauthorizedWithHttpInfo
     *
     * Get information about envelope by the invitation code (by unauthenticated user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteUnauthorized'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\InvitedEnvelopeInfoDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopeInviteUnauthorizedWithHttpInfo($code, string $contentType = self::contentTypes['getEnvelopeInviteUnauthorized'][0])
    {
        $request = $this->getEnvelopeInviteUnauthorizedRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\InvitedEnvelopeInfoDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\InvitedEnvelopeInfoDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvelopeInviteUnauthorizedAsync
     *
     * Get information about envelope by the invitation code (by unauthenticated user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteUnauthorized'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeInviteUnauthorizedAsync($code, string $contentType = self::contentTypes['getEnvelopeInviteUnauthorized'][0])
    {
        return $this->getEnvelopeInviteUnauthorizedAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvelopeInviteUnauthorizedAsyncWithHttpInfo
     *
     * Get information about envelope by the invitation code (by unauthenticated user)
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteUnauthorized'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeInviteUnauthorizedAsyncWithHttpInfo($code, string $contentType = self::contentTypes['getEnvelopeInviteUnauthorized'][0])
    {
        $returnType = '\DocStudio\Client\Model\InvitedEnvelopeInfoDTO';
        $request = $this->getEnvelopeInviteUnauthorizedRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvelopeInviteUnauthorized'
     *
     * @param  string $code Invitation code from email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeInviteUnauthorized'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEnvelopeInviteUnauthorizedRequest($code, string $contentType = self::contentTypes['getEnvelopeInviteUnauthorized'][0])
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling getEnvelopeInviteUnauthorized'
            );
        }


        $resourcePath = '/api/v1/envelope/invite-info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvelopeSharedZip
     *
     * Get shared zip archive
     *
     * @param  string $code Code for downloading (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeSharedZip'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getEnvelopeSharedZip($code, string $contentType = self::contentTypes['getEnvelopeSharedZip'][0])
    {
        list($response) = $this->getEnvelopeSharedZipWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation getEnvelopeSharedZipWithHttpInfo
     *
     * Get shared zip archive
     *
     * @param  string $code Code for downloading (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeSharedZip'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopeSharedZipWithHttpInfo($code, string $contentType = self::contentTypes['getEnvelopeSharedZip'][0])
    {
        $request = $this->getEnvelopeSharedZipRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvelopeSharedZipAsync
     *
     * Get shared zip archive
     *
     * @param  string $code Code for downloading (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeSharedZip'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeSharedZipAsync($code, string $contentType = self::contentTypes['getEnvelopeSharedZip'][0])
    {
        return $this->getEnvelopeSharedZipAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvelopeSharedZipAsyncWithHttpInfo
     *
     * Get shared zip archive
     *
     * @param  string $code Code for downloading (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeSharedZip'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeSharedZipAsyncWithHttpInfo($code, string $contentType = self::contentTypes['getEnvelopeSharedZip'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getEnvelopeSharedZipRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvelopeSharedZip'
     *
     * @param  string $code Code for downloading (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeSharedZip'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEnvelopeSharedZipRequest($code, string $contentType = self::contentTypes['getEnvelopeSharedZip'][0])
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling getEnvelopeSharedZip'
            );
        }
        if (strlen($code) > 32) {
            throw new \InvalidArgumentException('invalid length for "$code" when calling EnvelopeControllerApi.getEnvelopeSharedZip, must be smaller than or equal to 32.');
        }
        if (strlen($code) < 32) {
            throw new \InvalidArgumentException('invalid length for "$code" when calling EnvelopeControllerApi.getEnvelopeSharedZip, must be bigger than or equal to 32.');
        }
        

        $resourcePath = '/api/v1/envelope/download-shared';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvelopeZip
     *
     * Get envelope or document zip archive
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $document_id Document id (optional)
     * @param  string|null $exclude_files Mask to exclude some files. c - for signature/processing Certificate, p - for Printable version, a - for Audit trail (optional)
     * @param  string|null $zip_structure_name The name of pre-saved zip structure in the template (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeZip'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getEnvelopeZip($envelope_uuid, $mailbox, $document_id = null, $exclude_files = null, $zip_structure_name = null, string $contentType = self::contentTypes['getEnvelopeZip'][0])
    {
        list($response) = $this->getEnvelopeZipWithHttpInfo($envelope_uuid, $mailbox, $document_id, $exclude_files, $zip_structure_name, $contentType);
        return $response;
    }

    /**
     * Operation getEnvelopeZipWithHttpInfo
     *
     * Get envelope or document zip archive
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $document_id Document id (optional)
     * @param  string|null $exclude_files Mask to exclude some files. c - for signature/processing Certificate, p - for Printable version, a - for Audit trail (optional)
     * @param  string|null $zip_structure_name The name of pre-saved zip structure in the template (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeZip'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopeZipWithHttpInfo($envelope_uuid, $mailbox, $document_id = null, $exclude_files = null, $zip_structure_name = null, string $contentType = self::contentTypes['getEnvelopeZip'][0])
    {
        $request = $this->getEnvelopeZipRequest($envelope_uuid, $mailbox, $document_id, $exclude_files, $zip_structure_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvelopeZipAsync
     *
     * Get envelope or document zip archive
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $document_id Document id (optional)
     * @param  string|null $exclude_files Mask to exclude some files. c - for signature/processing Certificate, p - for Printable version, a - for Audit trail (optional)
     * @param  string|null $zip_structure_name The name of pre-saved zip structure in the template (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeZip'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeZipAsync($envelope_uuid, $mailbox, $document_id = null, $exclude_files = null, $zip_structure_name = null, string $contentType = self::contentTypes['getEnvelopeZip'][0])
    {
        return $this->getEnvelopeZipAsyncWithHttpInfo($envelope_uuid, $mailbox, $document_id, $exclude_files, $zip_structure_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvelopeZipAsyncWithHttpInfo
     *
     * Get envelope or document zip archive
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $document_id Document id (optional)
     * @param  string|null $exclude_files Mask to exclude some files. c - for signature/processing Certificate, p - for Printable version, a - for Audit trail (optional)
     * @param  string|null $zip_structure_name The name of pre-saved zip structure in the template (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeZip'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvelopeZipAsyncWithHttpInfo($envelope_uuid, $mailbox, $document_id = null, $exclude_files = null, $zip_structure_name = null, string $contentType = self::contentTypes['getEnvelopeZip'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getEnvelopeZipRequest($envelope_uuid, $mailbox, $document_id, $exclude_files, $zip_structure_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvelopeZip'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string|null $document_id Document id (optional)
     * @param  string|null $exclude_files Mask to exclude some files. c - for signature/processing Certificate, p - for Printable version, a - for Audit trail (optional)
     * @param  string|null $zip_structure_name The name of pre-saved zip structure in the template (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEnvelopeZip'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEnvelopeZipRequest($envelope_uuid, $mailbox, $document_id = null, $exclude_files = null, $zip_structure_name = null, string $contentType = self::contentTypes['getEnvelopeZip'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling getEnvelopeZip'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getEnvelopeZip'
            );
        }





        $resourcePath = '/api/v1/envelope/{envelopeUuid}/zip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_files,
            'excludeFiles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $zip_structure_name,
            'zipStructureName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMassSigningReport
     *
     * Get mass signing report
     *
     * @param  string $session_id Mass signing session UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMassSigningReport'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getMassSigningReport($session_id, $mailbox, string $contentType = self::contentTypes['getMassSigningReport'][0])
    {
        list($response) = $this->getMassSigningReportWithHttpInfo($session_id, $mailbox, $contentType);
        return $response;
    }

    /**
     * Operation getMassSigningReportWithHttpInfo
     *
     * Get mass signing report
     *
     * @param  string $session_id Mass signing session UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMassSigningReport'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMassSigningReportWithHttpInfo($session_id, $mailbox, string $contentType = self::contentTypes['getMassSigningReport'][0])
    {
        $request = $this->getMassSigningReportRequest($session_id, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMassSigningReportAsync
     *
     * Get mass signing report
     *
     * @param  string $session_id Mass signing session UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMassSigningReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMassSigningReportAsync($session_id, $mailbox, string $contentType = self::contentTypes['getMassSigningReport'][0])
    {
        return $this->getMassSigningReportAsyncWithHttpInfo($session_id, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMassSigningReportAsyncWithHttpInfo
     *
     * Get mass signing report
     *
     * @param  string $session_id Mass signing session UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMassSigningReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMassSigningReportAsyncWithHttpInfo($session_id, $mailbox, string $contentType = self::contentTypes['getMassSigningReport'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getMassSigningReportRequest($session_id, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMassSigningReport'
     *
     * @param  string $session_id Mass signing session UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMassSigningReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMassSigningReportRequest($session_id, $mailbox, string $contentType = self::contentTypes['getMassSigningReport'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling getMassSigningReport'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getMassSigningReport'
            );
        }


        $resourcePath = '/api/v1/envelope/signing-report/{sessionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sessionId' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserPendingInvitations
     *
     * Get user&#39;s pending invitations
     *
     * @param  int|null $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int|null $limit Limit, how much envelopes to retrieve (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO
     */
    public function getUserPendingInvitations($offset = 0, $limit = 25, string $contentType = self::contentTypes['getUserPendingInvitations'][0])
    {
        list($response) = $this->getUserPendingInvitationsWithHttpInfo($offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getUserPendingInvitationsWithHttpInfo
     *
     * Get user&#39;s pending invitations
     *
     * @param  int|null $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int|null $limit Limit, how much envelopes to retrieve (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserPendingInvitationsWithHttpInfo($offset = 0, $limit = 25, string $contentType = self::contentTypes['getUserPendingInvitations'][0])
    {
        $request = $this->getUserPendingInvitationsRequest($offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserPendingInvitationsAsync
     *
     * Get user&#39;s pending invitations
     *
     * @param  int|null $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int|null $limit Limit, how much envelopes to retrieve (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserPendingInvitationsAsync($offset = 0, $limit = 25, string $contentType = self::contentTypes['getUserPendingInvitations'][0])
    {
        return $this->getUserPendingInvitationsAsyncWithHttpInfo($offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserPendingInvitationsAsyncWithHttpInfo
     *
     * Get user&#39;s pending invitations
     *
     * @param  int|null $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int|null $limit Limit, how much envelopes to retrieve (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserPendingInvitationsAsyncWithHttpInfo($offset = 0, $limit = 25, string $contentType = self::contentTypes['getUserPendingInvitations'][0])
    {
        $returnType = '\DocStudio\Client\Model\PageDTOEnvelopeToMailboxDTO';
        $request = $this->getUserPendingInvitationsRequest($offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserPendingInvitations'
     *
     * @param  int|null $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int|null $limit Limit, how much envelopes to retrieve (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserPendingInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserPendingInvitationsRequest($offset = 0, $limit = 25, string $contentType = self::contentTypes['getUserPendingInvitations'][0])
    {




        $resourcePath = '/api/v1/envelope/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergeEnvelopesIntoChain
     *
     * Merge envelopes into chain
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function mergeEnvelopesIntoChain($mailbox, $request_body, string $contentType = self::contentTypes['mergeEnvelopesIntoChain'][0])
    {
        list($response) = $this->mergeEnvelopesIntoChainWithHttpInfo($mailbox, $request_body, $contentType);
        return $response;
    }

    /**
     * Operation mergeEnvelopesIntoChainWithHttpInfo
     *
     * Merge envelopes into chain
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeEnvelopesIntoChainWithHttpInfo($mailbox, $request_body, string $contentType = self::contentTypes['mergeEnvelopesIntoChain'][0])
    {
        $request = $this->mergeEnvelopesIntoChainRequest($mailbox, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergeEnvelopesIntoChainAsync
     *
     * Merge envelopes into chain
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeEnvelopesIntoChainAsync($mailbox, $request_body, string $contentType = self::contentTypes['mergeEnvelopesIntoChain'][0])
    {
        return $this->mergeEnvelopesIntoChainAsyncWithHttpInfo($mailbox, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeEnvelopesIntoChainAsyncWithHttpInfo
     *
     * Merge envelopes into chain
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeEnvelopesIntoChainAsyncWithHttpInfo($mailbox, $request_body, string $contentType = self::contentTypes['mergeEnvelopesIntoChain'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->mergeEnvelopesIntoChainRequest($mailbox, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergeEnvelopesIntoChain'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string[] $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeEnvelopesIntoChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mergeEnvelopesIntoChainRequest($mailbox, $request_body, string $contentType = self::contentTypes['mergeEnvelopesIntoChain'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling mergeEnvelopesIntoChain'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling mergeEnvelopesIntoChain'
            );
        }
        

        $resourcePath = '/api/v1/envelope/chain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation oneTimeSend
     *
     * The envelope will be sent just once (template will be marked as deleted)
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\OneTimeSendDTO $one_time_send_dto one_time_send_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oneTimeSend'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function oneTimeSend($mailbox, $one_time_send_dto, string $contentType = self::contentTypes['oneTimeSend'][0])
    {
        list($response) = $this->oneTimeSendWithHttpInfo($mailbox, $one_time_send_dto, $contentType);
        return $response;
    }

    /**
     * Operation oneTimeSendWithHttpInfo
     *
     * The envelope will be sent just once (template will be marked as deleted)
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\OneTimeSendDTO $one_time_send_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oneTimeSend'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function oneTimeSendWithHttpInfo($mailbox, $one_time_send_dto, string $contentType = self::contentTypes['oneTimeSend'][0])
    {
        $request = $this->oneTimeSendRequest($mailbox, $one_time_send_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oneTimeSendAsync
     *
     * The envelope will be sent just once (template will be marked as deleted)
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\OneTimeSendDTO $one_time_send_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oneTimeSend'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oneTimeSendAsync($mailbox, $one_time_send_dto, string $contentType = self::contentTypes['oneTimeSend'][0])
    {
        return $this->oneTimeSendAsyncWithHttpInfo($mailbox, $one_time_send_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oneTimeSendAsyncWithHttpInfo
     *
     * The envelope will be sent just once (template will be marked as deleted)
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\OneTimeSendDTO $one_time_send_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oneTimeSend'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oneTimeSendAsyncWithHttpInfo($mailbox, $one_time_send_dto, string $contentType = self::contentTypes['oneTimeSend'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->oneTimeSendRequest($mailbox, $one_time_send_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oneTimeSend'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\OneTimeSendDTO $one_time_send_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oneTimeSend'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oneTimeSendRequest($mailbox, $one_time_send_dto, string $contentType = self::contentTypes['oneTimeSend'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling oneTimeSend'
            );
        }

        // verify the required parameter 'one_time_send_dto' is set
        if ($one_time_send_dto === null || (is_array($one_time_send_dto) && count($one_time_send_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $one_time_send_dto when calling oneTimeSend'
            );
        }


        $resourcePath = '/api/v1/envelope/one-time-send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($one_time_send_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($one_time_send_dto));
            } else {
                $httpBody = $one_time_send_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickSendExternalDocuments
     *
     * Quick send envelope with external documents only
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \SplFileObject[] $files Files for external documents (required)
     * @param  \DocStudio\Client\Model\QuickSendDTO $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickSendExternalDocuments'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function quickSendExternalDocuments($mailbox, $files, $data, string $contentType = self::contentTypes['quickSendExternalDocuments'][0])
    {
        list($response) = $this->quickSendExternalDocumentsWithHttpInfo($mailbox, $files, $data, $contentType);
        return $response;
    }

    /**
     * Operation quickSendExternalDocumentsWithHttpInfo
     *
     * Quick send envelope with external documents only
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \SplFileObject[] $files Files for external documents (required)
     * @param  \DocStudio\Client\Model\QuickSendDTO $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickSendExternalDocuments'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickSendExternalDocumentsWithHttpInfo($mailbox, $files, $data, string $contentType = self::contentTypes['quickSendExternalDocuments'][0])
    {
        $request = $this->quickSendExternalDocumentsRequest($mailbox, $files, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quickSendExternalDocumentsAsync
     *
     * Quick send envelope with external documents only
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \SplFileObject[] $files Files for external documents (required)
     * @param  \DocStudio\Client\Model\QuickSendDTO $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickSendExternalDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickSendExternalDocumentsAsync($mailbox, $files, $data, string $contentType = self::contentTypes['quickSendExternalDocuments'][0])
    {
        return $this->quickSendExternalDocumentsAsyncWithHttpInfo($mailbox, $files, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickSendExternalDocumentsAsyncWithHttpInfo
     *
     * Quick send envelope with external documents only
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \SplFileObject[] $files Files for external documents (required)
     * @param  \DocStudio\Client\Model\QuickSendDTO $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickSendExternalDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickSendExternalDocumentsAsyncWithHttpInfo($mailbox, $files, $data, string $contentType = self::contentTypes['quickSendExternalDocuments'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->quickSendExternalDocumentsRequest($mailbox, $files, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickSendExternalDocuments'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \SplFileObject[] $files Files for external documents (required)
     * @param  \DocStudio\Client\Model\QuickSendDTO $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickSendExternalDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function quickSendExternalDocumentsRequest($mailbox, $files, $data, string $contentType = self::contentTypes['quickSendExternalDocuments'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling quickSendExternalDocuments'
            );
        }

        // verify the required parameter 'files' is set
        if ($files === null || (is_array($files) && count($files) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $files when calling quickSendExternalDocuments'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling quickSendExternalDocuments'
            );
        }


        $resourcePath = '/api/v1/envelope/quick-send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // form params
        if ($files !== null) {
            $multipart = true;
            $formParams['files'] = [];
            $paramFiles = is_array($files) ? $files : [$files];
            foreach ($paramFiles as $paramFile) {
                $formParams['files'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($data !== null) {
            $formParams['data'] = ObjectSerializer::toFormValue($data);
        }

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recycleBin
     *
     * Archive envelopes
     *
     * @param  bool $flag flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recycleBin'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function recycleBin($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['recycleBin'][0])
    {
        $this->recycleBinWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, $contentType);
    }

    /**
     * Operation recycleBinWithHttpInfo
     *
     * Archive envelopes
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recycleBin'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function recycleBinWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['recycleBin'][0])
    {
        $request = $this->recycleBinRequest($flag, $mailbox, $bulk_envelope_action_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation recycleBinAsync
     *
     * Archive envelopes
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recycleBin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recycleBinAsync($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['recycleBin'][0])
    {
        return $this->recycleBinAsyncWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recycleBinAsyncWithHttpInfo
     *
     * Archive envelopes
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recycleBin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recycleBinAsyncWithHttpInfo($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['recycleBin'][0])
    {
        $returnType = '';
        $request = $this->recycleBinRequest($flag, $mailbox, $bulk_envelope_action_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recycleBin'
     *
     * @param  bool $flag (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\BulkEnvelopeActionDTO $bulk_envelope_action_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recycleBin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recycleBinRequest($flag, $mailbox, $bulk_envelope_action_dto, string $contentType = self::contentTypes['recycleBin'][0])
    {

        // verify the required parameter 'flag' is set
        if ($flag === null || (is_array($flag) && count($flag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flag when calling recycleBin'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling recycleBin'
            );
        }

        // verify the required parameter 'bulk_envelope_action_dto' is set
        if ($bulk_envelope_action_dto === null || (is_array($bulk_envelope_action_dto) && count($bulk_envelope_action_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_envelope_action_dto when calling recycleBin'
            );
        }


        $resourcePath = '/api/v1/envelope/recycle-bin/{flag}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($flag !== null) {
            $resourcePath = str_replace(
                '{' . 'flag' . '}',
                ObjectSerializer::toPathValue($flag),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_envelope_action_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_envelope_action_dto));
            } else {
                $httpBody = $bulk_envelope_action_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeEnvelopeFromChain
     *
     * Remove envelope from chain
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeEnvelopeFromChain'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeEnvelopeFromChain($envelope_uuid, $mailbox, string $contentType = self::contentTypes['removeEnvelopeFromChain'][0])
    {
        $this->removeEnvelopeFromChainWithHttpInfo($envelope_uuid, $mailbox, $contentType);
    }

    /**
     * Operation removeEnvelopeFromChainWithHttpInfo
     *
     * Remove envelope from chain
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeEnvelopeFromChain'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeEnvelopeFromChainWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['removeEnvelopeFromChain'][0])
    {
        $request = $this->removeEnvelopeFromChainRequest($envelope_uuid, $mailbox, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeEnvelopeFromChainAsync
     *
     * Remove envelope from chain
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeEnvelopeFromChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeEnvelopeFromChainAsync($envelope_uuid, $mailbox, string $contentType = self::contentTypes['removeEnvelopeFromChain'][0])
    {
        return $this->removeEnvelopeFromChainAsyncWithHttpInfo($envelope_uuid, $mailbox, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeEnvelopeFromChainAsyncWithHttpInfo
     *
     * Remove envelope from chain
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeEnvelopeFromChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeEnvelopeFromChainAsyncWithHttpInfo($envelope_uuid, $mailbox, string $contentType = self::contentTypes['removeEnvelopeFromChain'][0])
    {
        $returnType = '';
        $request = $this->removeEnvelopeFromChainRequest($envelope_uuid, $mailbox, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeEnvelopeFromChain'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeEnvelopeFromChain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeEnvelopeFromChainRequest($envelope_uuid, $mailbox, string $contentType = self::contentTypes['removeEnvelopeFromChain'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling removeEnvelopeFromChain'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling removeEnvelopeFromChain'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/chain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendNotifications
     *
     * Resend notifications for active roles
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ReportEnvelopeRequestDTO $report_envelope_request_dto report_envelope_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendNotifications'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resendNotifications($mailbox, $report_envelope_request_dto, string $contentType = self::contentTypes['resendNotifications'][0])
    {
        $this->resendNotificationsWithHttpInfo($mailbox, $report_envelope_request_dto, $contentType);
    }

    /**
     * Operation resendNotificationsWithHttpInfo
     *
     * Resend notifications for active roles
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ReportEnvelopeRequestDTO $report_envelope_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendNotifications'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resendNotificationsWithHttpInfo($mailbox, $report_envelope_request_dto, string $contentType = self::contentTypes['resendNotifications'][0])
    {
        $request = $this->resendNotificationsRequest($mailbox, $report_envelope_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resendNotificationsAsync
     *
     * Resend notifications for active roles
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ReportEnvelopeRequestDTO $report_envelope_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resendNotificationsAsync($mailbox, $report_envelope_request_dto, string $contentType = self::contentTypes['resendNotifications'][0])
    {
        return $this->resendNotificationsAsyncWithHttpInfo($mailbox, $report_envelope_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resendNotificationsAsyncWithHttpInfo
     *
     * Resend notifications for active roles
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ReportEnvelopeRequestDTO $report_envelope_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resendNotificationsAsyncWithHttpInfo($mailbox, $report_envelope_request_dto, string $contentType = self::contentTypes['resendNotifications'][0])
    {
        $returnType = '';
        $request = $this->resendNotificationsRequest($mailbox, $report_envelope_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resendNotifications'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ReportEnvelopeRequestDTO $report_envelope_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resendNotificationsRequest($mailbox, $report_envelope_request_dto, string $contentType = self::contentTypes['resendNotifications'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling resendNotifications'
            );
        }

        // verify the required parameter 'report_envelope_request_dto' is set
        if ($report_envelope_request_dto === null || (is_array($report_envelope_request_dto) && count($report_envelope_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $report_envelope_request_dto when calling resendNotifications'
            );
        }


        $resourcePath = '/api/v1/envelope/notify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($report_envelope_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($report_envelope_request_dto));
            } else {
                $httpBody = $report_envelope_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resolvedEnvelopeComment
     *
     * Set Resolved Flag for comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ResolveCommentThreadDTO $resolve_comment_thread_dto resolve_comment_thread_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resolvedEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resolvedEnvelopeComment($envelope_uuid, $mailbox, $resolve_comment_thread_dto, string $contentType = self::contentTypes['resolvedEnvelopeComment'][0])
    {
        $this->resolvedEnvelopeCommentWithHttpInfo($envelope_uuid, $mailbox, $resolve_comment_thread_dto, $contentType);
    }

    /**
     * Operation resolvedEnvelopeCommentWithHttpInfo
     *
     * Set Resolved Flag for comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ResolveCommentThreadDTO $resolve_comment_thread_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resolvedEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resolvedEnvelopeCommentWithHttpInfo($envelope_uuid, $mailbox, $resolve_comment_thread_dto, string $contentType = self::contentTypes['resolvedEnvelopeComment'][0])
    {
        $request = $this->resolvedEnvelopeCommentRequest($envelope_uuid, $mailbox, $resolve_comment_thread_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resolvedEnvelopeCommentAsync
     *
     * Set Resolved Flag for comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ResolveCommentThreadDTO $resolve_comment_thread_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resolvedEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resolvedEnvelopeCommentAsync($envelope_uuid, $mailbox, $resolve_comment_thread_dto, string $contentType = self::contentTypes['resolvedEnvelopeComment'][0])
    {
        return $this->resolvedEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $mailbox, $resolve_comment_thread_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resolvedEnvelopeCommentAsyncWithHttpInfo
     *
     * Set Resolved Flag for comment thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ResolveCommentThreadDTO $resolve_comment_thread_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resolvedEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resolvedEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $mailbox, $resolve_comment_thread_dto, string $contentType = self::contentTypes['resolvedEnvelopeComment'][0])
    {
        $returnType = '';
        $request = $this->resolvedEnvelopeCommentRequest($envelope_uuid, $mailbox, $resolve_comment_thread_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resolvedEnvelopeComment'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\ResolveCommentThreadDTO $resolve_comment_thread_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resolvedEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resolvedEnvelopeCommentRequest($envelope_uuid, $mailbox, $resolve_comment_thread_dto, string $contentType = self::contentTypes['resolvedEnvelopeComment'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling resolvedEnvelopeComment'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling resolvedEnvelopeComment'
            );
        }

        // verify the required parameter 'resolve_comment_thread_dto' is set
        if ($resolve_comment_thread_dto === null || (is_array($resolve_comment_thread_dto) && count($resolve_comment_thread_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolve_comment_thread_dto when calling resolvedEnvelopeComment'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/resolve-comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resolve_comment_thread_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resolve_comment_thread_dto));
            } else {
                $httpBody = $resolve_comment_thread_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation revokeEnvelopeSharing
     *
     * Revoke sharing an envelope copy
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeEnvelopeSharing'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function revokeEnvelopeSharing($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['revokeEnvelopeSharing'][0])
    {
        $this->revokeEnvelopeSharingWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, $contentType);
    }

    /**
     * Operation revokeEnvelopeSharingWithHttpInfo
     *
     * Revoke sharing an envelope copy
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeEnvelopeSharing'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function revokeEnvelopeSharingWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['revokeEnvelopeSharing'][0])
    {
        $request = $this->revokeEnvelopeSharingRequest($mailbox, $envelope_shared_copy_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation revokeEnvelopeSharingAsync
     *
     * Revoke sharing an envelope copy
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeEnvelopeSharing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeEnvelopeSharingAsync($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['revokeEnvelopeSharing'][0])
    {
        return $this->revokeEnvelopeSharingAsyncWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation revokeEnvelopeSharingAsyncWithHttpInfo
     *
     * Revoke sharing an envelope copy
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeEnvelopeSharing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeEnvelopeSharingAsyncWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['revokeEnvelopeSharing'][0])
    {
        $returnType = '';
        $request = $this->revokeEnvelopeSharingRequest($mailbox, $envelope_shared_copy_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'revokeEnvelopeSharing'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeEnvelopeSharing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function revokeEnvelopeSharingRequest($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['revokeEnvelopeSharing'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling revokeEnvelopeSharing'
            );
        }

        // verify the required parameter 'envelope_shared_copy_request_dto' is set
        if ($envelope_shared_copy_request_dto === null || (is_array($envelope_shared_copy_request_dto) && count($envelope_shared_copy_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_shared_copy_request_dto when calling revokeEnvelopeSharing'
            );
        }


        $resourcePath = '/api/v1/envelope/share-copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_shared_copy_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_shared_copy_request_dto));
            } else {
                $httpBody = $envelope_shared_copy_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation send
     *
     * Send envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['send'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function send($mailbox, $env_post_dto, string $contentType = self::contentTypes['send'][0])
    {
        list($response) = $this->sendWithHttpInfo($mailbox, $env_post_dto, $contentType);
        return $response;
    }

    /**
     * Operation sendWithHttpInfo
     *
     * Send envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['send'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['send'][0])
    {
        $request = $this->sendRequest($mailbox, $env_post_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendAsync
     *
     * Send envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['send'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAsync($mailbox, $env_post_dto, string $contentType = self::contentTypes['send'][0])
    {
        return $this->sendAsyncWithHttpInfo($mailbox, $env_post_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendAsyncWithHttpInfo
     *
     * Send envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['send'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAsyncWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['send'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->sendRequest($mailbox, $env_post_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'send'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['send'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendRequest($mailbox, $env_post_dto, string $contentType = self::contentTypes['send'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling send'
            );
        }

        // verify the required parameter 'env_post_dto' is set
        if ($env_post_dto === null || (is_array($env_post_dto) && count($env_post_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_post_dto when calling send'
            );
        }


        $resourcePath = '/api/v1/envelope/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_post_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_post_dto));
            } else {
                $httpBody = $env_post_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendByTemplateCode
     *
     * Send envelope by template code
     *
     * @param  \DocStudio\Client\Model\SendEnvByCodeDTO $send_env_by_code_dto send_env_by_code_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByTemplateCode'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\LoginEnvelopeResponseDTO|\DocStudio\Client\Model\CommonExceptionDTO
     */
    public function sendByTemplateCode($send_env_by_code_dto, string $contentType = self::contentTypes['sendByTemplateCode'][0])
    {
        list($response) = $this->sendByTemplateCodeWithHttpInfo($send_env_by_code_dto, $contentType);
        return $response;
    }

    /**
     * Operation sendByTemplateCodeWithHttpInfo
     *
     * Send envelope by template code
     *
     * @param  \DocStudio\Client\Model\SendEnvByCodeDTO $send_env_by_code_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByTemplateCode'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\LoginEnvelopeResponseDTO|\DocStudio\Client\Model\CommonExceptionDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendByTemplateCodeWithHttpInfo($send_env_by_code_dto, string $contentType = self::contentTypes['sendByTemplateCode'][0])
    {
        $request = $this->sendByTemplateCodeRequest($send_env_by_code_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\DocStudio\Client\Model\LoginEnvelopeResponseDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\LoginEnvelopeResponseDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\LoginEnvelopeResponseDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\DocStudio\Client\Model\CommonExceptionDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\CommonExceptionDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\CommonExceptionDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\LoginEnvelopeResponseDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\LoginEnvelopeResponseDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\CommonExceptionDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendByTemplateCodeAsync
     *
     * Send envelope by template code
     *
     * @param  \DocStudio\Client\Model\SendEnvByCodeDTO $send_env_by_code_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByTemplateCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendByTemplateCodeAsync($send_env_by_code_dto, string $contentType = self::contentTypes['sendByTemplateCode'][0])
    {
        return $this->sendByTemplateCodeAsyncWithHttpInfo($send_env_by_code_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendByTemplateCodeAsyncWithHttpInfo
     *
     * Send envelope by template code
     *
     * @param  \DocStudio\Client\Model\SendEnvByCodeDTO $send_env_by_code_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByTemplateCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendByTemplateCodeAsyncWithHttpInfo($send_env_by_code_dto, string $contentType = self::contentTypes['sendByTemplateCode'][0])
    {
        $returnType = '\DocStudio\Client\Model\LoginEnvelopeResponseDTO';
        $request = $this->sendByTemplateCodeRequest($send_env_by_code_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendByTemplateCode'
     *
     * @param  \DocStudio\Client\Model\SendEnvByCodeDTO $send_env_by_code_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByTemplateCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendByTemplateCodeRequest($send_env_by_code_dto, string $contentType = self::contentTypes['sendByTemplateCode'][0])
    {

        // verify the required parameter 'send_env_by_code_dto' is set
        if ($send_env_by_code_dto === null || (is_array($send_env_by_code_dto) && count($send_env_by_code_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $send_env_by_code_dto when calling sendByTemplateCode'
            );
        }


        $resourcePath = '/api/v1/envelope/send-by-share-code';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($send_env_by_code_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($send_env_by_code_dto));
            } else {
                $httpBody = $send_env_by_code_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendForApproval
     *
     * Send envelope for approval
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeApprovalRequestDTO $envelope_approval_request_dto envelope_approval_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendForApproval'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\SingleUuidDTO
     */
    public function sendForApproval($mailbox, $envelope_approval_request_dto, string $contentType = self::contentTypes['sendForApproval'][0])
    {
        list($response) = $this->sendForApprovalWithHttpInfo($mailbox, $envelope_approval_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation sendForApprovalWithHttpInfo
     *
     * Send envelope for approval
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeApprovalRequestDTO $envelope_approval_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendForApproval'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\SingleUuidDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendForApprovalWithHttpInfo($mailbox, $envelope_approval_request_dto, string $contentType = self::contentTypes['sendForApproval'][0])
    {
        $request = $this->sendForApprovalRequest($mailbox, $envelope_approval_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\SingleUuidDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\SingleUuidDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\SingleUuidDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\SingleUuidDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendForApprovalAsync
     *
     * Send envelope for approval
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeApprovalRequestDTO $envelope_approval_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendForApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendForApprovalAsync($mailbox, $envelope_approval_request_dto, string $contentType = self::contentTypes['sendForApproval'][0])
    {
        return $this->sendForApprovalAsyncWithHttpInfo($mailbox, $envelope_approval_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendForApprovalAsyncWithHttpInfo
     *
     * Send envelope for approval
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeApprovalRequestDTO $envelope_approval_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendForApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendForApprovalAsyncWithHttpInfo($mailbox, $envelope_approval_request_dto, string $contentType = self::contentTypes['sendForApproval'][0])
    {
        $returnType = '\DocStudio\Client\Model\SingleUuidDTO';
        $request = $this->sendForApprovalRequest($mailbox, $envelope_approval_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendForApproval'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeApprovalRequestDTO $envelope_approval_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendForApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendForApprovalRequest($mailbox, $envelope_approval_request_dto, string $contentType = self::contentTypes['sendForApproval'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling sendForApproval'
            );
        }

        // verify the required parameter 'envelope_approval_request_dto' is set
        if ($envelope_approval_request_dto === null || (is_array($envelope_approval_request_dto) && count($envelope_approval_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_approval_request_dto when calling sendForApproval'
            );
        }


        $resourcePath = '/api/v1/envelope/send-for-approval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_approval_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_approval_request_dto));
            } else {
                $httpBody = $envelope_approval_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shareEnvelopesByEmail
     *
     * Share envelopes by email
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedArchiveRequestDTO $envelope_shared_archive_request_dto envelope_shared_archive_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesByEmail'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function shareEnvelopesByEmail($mailbox, $envelope_shared_archive_request_dto, string $contentType = self::contentTypes['shareEnvelopesByEmail'][0])
    {
        $this->shareEnvelopesByEmailWithHttpInfo($mailbox, $envelope_shared_archive_request_dto, $contentType);
    }

    /**
     * Operation shareEnvelopesByEmailWithHttpInfo
     *
     * Share envelopes by email
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedArchiveRequestDTO $envelope_shared_archive_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesByEmail'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function shareEnvelopesByEmailWithHttpInfo($mailbox, $envelope_shared_archive_request_dto, string $contentType = self::contentTypes['shareEnvelopesByEmail'][0])
    {
        $request = $this->shareEnvelopesByEmailRequest($mailbox, $envelope_shared_archive_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation shareEnvelopesByEmailAsync
     *
     * Share envelopes by email
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedArchiveRequestDTO $envelope_shared_archive_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesByEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareEnvelopesByEmailAsync($mailbox, $envelope_shared_archive_request_dto, string $contentType = self::contentTypes['shareEnvelopesByEmail'][0])
    {
        return $this->shareEnvelopesByEmailAsyncWithHttpInfo($mailbox, $envelope_shared_archive_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shareEnvelopesByEmailAsyncWithHttpInfo
     *
     * Share envelopes by email
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedArchiveRequestDTO $envelope_shared_archive_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesByEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareEnvelopesByEmailAsyncWithHttpInfo($mailbox, $envelope_shared_archive_request_dto, string $contentType = self::contentTypes['shareEnvelopesByEmail'][0])
    {
        $returnType = '';
        $request = $this->shareEnvelopesByEmailRequest($mailbox, $envelope_shared_archive_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shareEnvelopesByEmail'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedArchiveRequestDTO $envelope_shared_archive_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesByEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function shareEnvelopesByEmailRequest($mailbox, $envelope_shared_archive_request_dto, string $contentType = self::contentTypes['shareEnvelopesByEmail'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling shareEnvelopesByEmail'
            );
        }

        // verify the required parameter 'envelope_shared_archive_request_dto' is set
        if ($envelope_shared_archive_request_dto === null || (is_array($envelope_shared_archive_request_dto) && count($envelope_shared_archive_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_shared_archive_request_dto when calling shareEnvelopesByEmail'
            );
        }


        $resourcePath = '/api/v1/envelope/share-archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_shared_archive_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_shared_archive_request_dto));
            } else {
                $httpBody = $envelope_shared_archive_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shareEnvelopesCopy
     *
     * Share envelopes copies
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesCopy'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function shareEnvelopesCopy($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['shareEnvelopesCopy'][0])
    {
        $this->shareEnvelopesCopyWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, $contentType);
    }

    /**
     * Operation shareEnvelopesCopyWithHttpInfo
     *
     * Share envelopes copies
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesCopy'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function shareEnvelopesCopyWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['shareEnvelopesCopy'][0])
    {
        $request = $this->shareEnvelopesCopyRequest($mailbox, $envelope_shared_copy_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation shareEnvelopesCopyAsync
     *
     * Share envelopes copies
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareEnvelopesCopyAsync($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['shareEnvelopesCopy'][0])
    {
        return $this->shareEnvelopesCopyAsyncWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shareEnvelopesCopyAsyncWithHttpInfo
     *
     * Share envelopes copies
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareEnvelopesCopyAsyncWithHttpInfo($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['shareEnvelopesCopy'][0])
    {
        $returnType = '';
        $request = $this->shareEnvelopesCopyRequest($mailbox, $envelope_shared_copy_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shareEnvelopesCopy'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeSharedCopyRequestDTO $envelope_shared_copy_request_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shareEnvelopesCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function shareEnvelopesCopyRequest($mailbox, $envelope_shared_copy_request_dto, string $contentType = self::contentTypes['shareEnvelopesCopy'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling shareEnvelopesCopy'
            );
        }

        // verify the required parameter 'envelope_shared_copy_request_dto' is set
        if ($envelope_shared_copy_request_dto === null || (is_array($envelope_shared_copy_request_dto) && count($envelope_shared_copy_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_shared_copy_request_dto when calling shareEnvelopesCopy'
            );
        }


        $resourcePath = '/api/v1/envelope/share-copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_shared_copy_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_shared_copy_request_dto));
            } else {
                $httpBody = $envelope_shared_copy_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sign
     *
     * Sign envelope documents
     *
     * @param  string $envelope_uuid Envelope to update (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeDocumentSignaturesDTO[] $envelope_document_signatures_dto envelope_document_signatures_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sign($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id = null, string $contentType = self::contentTypes['sign'][0])
    {
        $this->signWithHttpInfo($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id, $contentType);
    }

    /**
     * Operation signWithHttpInfo
     *
     * Sign envelope documents
     *
     * @param  string $envelope_uuid Envelope to update (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeDocumentSignaturesDTO[] $envelope_document_signatures_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sign'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function signWithHttpInfo($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id = null, string $contentType = self::contentTypes['sign'][0])
    {
        $request = $this->signRequest($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation signAsync
     *
     * Sign envelope documents
     *
     * @param  string $envelope_uuid Envelope to update (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeDocumentSignaturesDTO[] $envelope_document_signatures_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signAsync($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id = null, string $contentType = self::contentTypes['sign'][0])
    {
        return $this->signAsyncWithHttpInfo($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signAsyncWithHttpInfo
     *
     * Sign envelope documents
     *
     * @param  string $envelope_uuid Envelope to update (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeDocumentSignaturesDTO[] $envelope_document_signatures_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signAsyncWithHttpInfo($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id = null, string $contentType = self::contentTypes['sign'][0])
    {
        $returnType = '';
        $request = $this->signRequest($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sign'
     *
     * @param  string $envelope_uuid Envelope to update (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvelopeDocumentSignaturesDTO[] $envelope_document_signatures_dto (required)
     * @param  string|null $session_id Mass signing session UUID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signRequest($envelope_uuid, $mailbox, $envelope_document_signatures_dto, $session_id = null, string $contentType = self::contentTypes['sign'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling sign'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling sign'
            );
        }

        // verify the required parameter 'envelope_document_signatures_dto' is set
        if ($envelope_document_signatures_dto === null || (is_array($envelope_document_signatures_dto) && count($envelope_document_signatures_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_document_signatures_dto when calling sign'
            );
        }



        $resourcePath = '/api/v1/envelope/{envelopeUuid}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $session_id,
            'sessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($envelope_document_signatures_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($envelope_document_signatures_dto));
            } else {
                $httpBody = $envelope_document_signatures_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signSES
     *
     * Sign envelope with SES
     *
     * @param  string $envelope_uuid Envelope to fill (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signSES'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function signSES($envelope_uuid, $mailbox, $body, string $contentType = self::contentTypes['signSES'][0])
    {
        $this->signSESWithHttpInfo($envelope_uuid, $mailbox, $body, $contentType);
    }

    /**
     * Operation signSESWithHttpInfo
     *
     * Sign envelope with SES
     *
     * @param  string $envelope_uuid Envelope to fill (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signSES'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function signSESWithHttpInfo($envelope_uuid, $mailbox, $body, string $contentType = self::contentTypes['signSES'][0])
    {
        $request = $this->signSESRequest($envelope_uuid, $mailbox, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation signSESAsync
     *
     * Sign envelope with SES
     *
     * @param  string $envelope_uuid Envelope to fill (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signSES'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signSESAsync($envelope_uuid, $mailbox, $body, string $contentType = self::contentTypes['signSES'][0])
    {
        return $this->signSESAsyncWithHttpInfo($envelope_uuid, $mailbox, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signSESAsyncWithHttpInfo
     *
     * Sign envelope with SES
     *
     * @param  string $envelope_uuid Envelope to fill (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signSES'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signSESAsyncWithHttpInfo($envelope_uuid, $mailbox, $body, string $contentType = self::contentTypes['signSES'][0])
    {
        $returnType = '';
        $request = $this->signSESRequest($envelope_uuid, $mailbox, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signSES'
     *
     * @param  string $envelope_uuid Envelope to fill (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signSES'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signSESRequest($envelope_uuid, $mailbox, $body, string $contentType = self::contentTypes['signSES'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling signSES'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling signSES'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling signSES'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/sign-ses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEnvelope
     *
     * Update draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelope'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateEnvelope($mailbox, $env_post_dto, string $contentType = self::contentTypes['updateEnvelope'][0])
    {
        $this->updateEnvelopeWithHttpInfo($mailbox, $env_post_dto, $contentType);
    }

    /**
     * Operation updateEnvelopeWithHttpInfo
     *
     * Update draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelope'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEnvelopeWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['updateEnvelope'][0])
    {
        $request = $this->updateEnvelopeRequest($mailbox, $env_post_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateEnvelopeAsync
     *
     * Update draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelope'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEnvelopeAsync($mailbox, $env_post_dto, string $contentType = self::contentTypes['updateEnvelope'][0])
    {
        return $this->updateEnvelopeAsyncWithHttpInfo($mailbox, $env_post_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEnvelopeAsyncWithHttpInfo
     *
     * Update draft envelope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelope'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEnvelopeAsyncWithHttpInfo($mailbox, $env_post_dto, string $contentType = self::contentTypes['updateEnvelope'][0])
    {
        $returnType = '';
        $request = $this->updateEnvelopeRequest($mailbox, $env_post_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEnvelope'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\EnvPostDTO $env_post_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelope'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEnvelopeRequest($mailbox, $env_post_dto, string $contentType = self::contentTypes['updateEnvelope'][0])
    {

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling updateEnvelope'
            );
        }

        // verify the required parameter 'env_post_dto' is set
        if ($env_post_dto === null || (is_array($env_post_dto) && count($env_post_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env_post_dto when calling updateEnvelope'
            );
        }


        $resourcePath = '/api/v1/envelope';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($env_post_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($env_post_dto));
            } else {
                $httpBody = $env_post_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEnvelopeComment
     *
     * Add/Update envelope comment in thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPutDTO $comment_put_dto comment_put_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\CommentThreadDTO
     */
    public function updateEnvelopeComment($envelope_uuid, $mailbox, $comment_put_dto, string $contentType = self::contentTypes['updateEnvelopeComment'][0])
    {
        list($response) = $this->updateEnvelopeCommentWithHttpInfo($envelope_uuid, $mailbox, $comment_put_dto, $contentType);
        return $response;
    }

    /**
     * Operation updateEnvelopeCommentWithHttpInfo
     *
     * Add/Update envelope comment in thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPutDTO $comment_put_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\CommentThreadDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEnvelopeCommentWithHttpInfo($envelope_uuid, $mailbox, $comment_put_dto, string $contentType = self::contentTypes['updateEnvelopeComment'][0])
    {
        $request = $this->updateEnvelopeCommentRequest($envelope_uuid, $mailbox, $comment_put_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\CommentThreadDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\CommentThreadDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\CommentThreadDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\CommentThreadDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEnvelopeCommentAsync
     *
     * Add/Update envelope comment in thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPutDTO $comment_put_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEnvelopeCommentAsync($envelope_uuid, $mailbox, $comment_put_dto, string $contentType = self::contentTypes['updateEnvelopeComment'][0])
    {
        return $this->updateEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $mailbox, $comment_put_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEnvelopeCommentAsyncWithHttpInfo
     *
     * Add/Update envelope comment in thread
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPutDTO $comment_put_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEnvelopeCommentAsyncWithHttpInfo($envelope_uuid, $mailbox, $comment_put_dto, string $contentType = self::contentTypes['updateEnvelopeComment'][0])
    {
        $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
        $request = $this->updateEnvelopeCommentRequest($envelope_uuid, $mailbox, $comment_put_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEnvelopeComment'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentPutDTO $comment_put_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEnvelopeCommentRequest($envelope_uuid, $mailbox, $comment_put_dto, string $contentType = self::contentTypes['updateEnvelopeComment'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling updateEnvelopeComment'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling updateEnvelopeComment'
            );
        }

        // verify the required parameter 'comment_put_dto' is set
        if ($comment_put_dto === null || (is_array($comment_put_dto) && count($comment_put_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_put_dto when calling updateEnvelopeComment'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_put_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($comment_put_dto));
            } else {
                $httpBody = $comment_put_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEnvelopeCommentAccess
     *
     * Update envelope comment thread access level
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentAccessDTO $comment_access_dto comment_access_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeCommentAccess'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocStudio\Client\Model\CommentThreadDTO
     */
    public function updateEnvelopeCommentAccess($envelope_uuid, $mailbox, $comment_access_dto, string $contentType = self::contentTypes['updateEnvelopeCommentAccess'][0])
    {
        list($response) = $this->updateEnvelopeCommentAccessWithHttpInfo($envelope_uuid, $mailbox, $comment_access_dto, $contentType);
        return $response;
    }

    /**
     * Operation updateEnvelopeCommentAccessWithHttpInfo
     *
     * Update envelope comment thread access level
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentAccessDTO $comment_access_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeCommentAccess'] to see the possible values for this operation
     *
     * @throws \DocStudio\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocStudio\Client\Model\CommentThreadDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEnvelopeCommentAccessWithHttpInfo($envelope_uuid, $mailbox, $comment_access_dto, string $contentType = self::contentTypes['updateEnvelopeCommentAccess'][0])
    {
        $request = $this->updateEnvelopeCommentAccessRequest($envelope_uuid, $mailbox, $comment_access_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\DocStudio\Client\Model\CommentThreadDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DocStudio\Client\Model\CommentThreadDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DocStudio\Client\Model\CommentThreadDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocStudio\Client\Model\CommentThreadDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEnvelopeCommentAccessAsync
     *
     * Update envelope comment thread access level
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentAccessDTO $comment_access_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeCommentAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEnvelopeCommentAccessAsync($envelope_uuid, $mailbox, $comment_access_dto, string $contentType = self::contentTypes['updateEnvelopeCommentAccess'][0])
    {
        return $this->updateEnvelopeCommentAccessAsyncWithHttpInfo($envelope_uuid, $mailbox, $comment_access_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEnvelopeCommentAccessAsyncWithHttpInfo
     *
     * Update envelope comment thread access level
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentAccessDTO $comment_access_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeCommentAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEnvelopeCommentAccessAsyncWithHttpInfo($envelope_uuid, $mailbox, $comment_access_dto, string $contentType = self::contentTypes['updateEnvelopeCommentAccess'][0])
    {
        $returnType = '\DocStudio\Client\Model\CommentThreadDTO';
        $request = $this->updateEnvelopeCommentAccessRequest($envelope_uuid, $mailbox, $comment_access_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEnvelopeCommentAccess'
     *
     * @param  string $envelope_uuid Envelope UUID (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  \DocStudio\Client\Model\CommentAccessDTO $comment_access_dto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEnvelopeCommentAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEnvelopeCommentAccessRequest($envelope_uuid, $mailbox, $comment_access_dto, string $contentType = self::contentTypes['updateEnvelopeCommentAccess'][0])
    {

        // verify the required parameter 'envelope_uuid' is set
        if ($envelope_uuid === null || (is_array($envelope_uuid) && count($envelope_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envelope_uuid when calling updateEnvelopeCommentAccess'
            );
        }

        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling updateEnvelopeCommentAccess'
            );
        }

        // verify the required parameter 'comment_access_dto' is set
        if ($comment_access_dto === null || (is_array($comment_access_dto) && count($comment_access_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_access_dto when calling updateEnvelopeCommentAccess'
            );
        }


        $resourcePath = '/api/v1/envelope/{envelopeUuid}/comment-access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }

        // path params
        if ($envelope_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'envelopeUuid' . '}',
                ObjectSerializer::toPathValue($envelope_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_access_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($comment_access_dto));
            } else {
                $httpBody = $comment_access_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
