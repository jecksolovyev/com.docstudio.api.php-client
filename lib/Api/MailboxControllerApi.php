<?php
/**
 * MailboxControllerApi
 * PHP version 5
 *
 * @category Class
 * @package  Docstudio\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * DocStudio Api Documentation
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: R74.25
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.41
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Docstudio\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Docstudio\Client\ApiException;
use Docstudio\Client\Configuration;
use Docstudio\Client\HeaderSelector;
use Docstudio\Client\ObjectSerializer;

/**
 * MailboxControllerApi Class Doc Comment
 *
 * @category Class
 * @package  Docstudio\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class MailboxControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createMailbox
     *
     * Create mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxCreateDTO $body body (required)
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     * @param  string $code Invitation code from email (optional)
     * @param  string $code_type Type of code (optional)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\User2MailboxDTO
     */
    public function createMailbox($body, $uuid, $code = null, $code_type = null)
    {
        list($response) = $this->createMailboxWithHttpInfo($body, $uuid, $code, $code_type);
        return $response;
    }

    /**
     * Operation createMailboxWithHttpInfo
     *
     * Create mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxCreateDTO $body (required)
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     * @param  string $code Invitation code from email (optional)
     * @param  string $code_type Type of code (optional)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\User2MailboxDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMailboxWithHttpInfo($body, $uuid, $code = null, $code_type = null)
    {
        $returnType = '\Swagger\Client\Model\User2MailboxDTO';
        $request = $this->createMailboxRequest($body, $uuid, $code, $code_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\User2MailboxDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createMailboxAsync
     *
     * Create mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxCreateDTO $body (required)
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     * @param  string $code Invitation code from email (optional)
     * @param  string $code_type Type of code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMailboxAsync($body, $uuid, $code = null, $code_type = null)
    {
        return $this->createMailboxAsyncWithHttpInfo($body, $uuid, $code, $code_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMailboxAsyncWithHttpInfo
     *
     * Create mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxCreateDTO $body (required)
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     * @param  string $code Invitation code from email (optional)
     * @param  string $code_type Type of code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMailboxAsyncWithHttpInfo($body, $uuid, $code = null, $code_type = null)
    {
        $returnType = '\Swagger\Client\Model\User2MailboxDTO';
        $request = $this->createMailboxRequest($body, $uuid, $code, $code_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMailbox'
     *
     * @param  \Docstudio\Client\Model\MailboxCreateDTO $body (required)
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     * @param  string $code Invitation code from email (optional)
     * @param  string $code_type Type of code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createMailboxRequest($body, $uuid, $code = null, $code_type = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createMailbox'
            );
        }
        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling createMailbox'
            );
        }

        $resourcePath = '/api/v1/mailbox/account/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($code_type !== null) {
            $queryParams['codeType'] = ObjectSerializer::toQueryValue($code_type, null);
        }

        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMailbox
     *
     * Delete mailbox by UUID in the header.
     *
     * @param  string $check_message Proof message (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMailbox($check_message, $mailbox)
    {
        $this->deleteMailboxWithHttpInfo($check_message, $mailbox);
    }

    /**
     * Operation deleteMailboxWithHttpInfo
     *
     * Delete mailbox by UUID in the header.
     *
     * @param  string $check_message Proof message (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMailboxWithHttpInfo($check_message, $mailbox)
    {
        $returnType = '';
        $request = $this->deleteMailboxRequest($check_message, $mailbox);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMailboxAsync
     *
     * Delete mailbox by UUID in the header.
     *
     * @param  string $check_message Proof message (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMailboxAsync($check_message, $mailbox)
    {
        return $this->deleteMailboxAsyncWithHttpInfo($check_message, $mailbox)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMailboxAsyncWithHttpInfo
     *
     * Delete mailbox by UUID in the header.
     *
     * @param  string $check_message Proof message (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMailboxAsyncWithHttpInfo($check_message, $mailbox)
    {
        $returnType = '';
        $request = $this->deleteMailboxRequest($check_message, $mailbox);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMailbox'
     *
     * @param  string $check_message Proof message (required)
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMailboxRequest($check_message, $mailbox)
    {
        // verify the required parameter 'check_message' is set
        if ($check_message === null || (is_array($check_message) && count($check_message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_message when calling deleteMailbox'
            );
        }
        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling deleteMailbox'
            );
        }

        $resourcePath = '/api/v1/mailbox';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($check_message !== null) {
            $queryParams['checkMessage'] = ObjectSerializer::toQueryValue($check_message, null);
        }
        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMailboxUsers
     *
     * Delete mailbox users except requester
     *
     * @param  string $mailbox_uuid Mailbox UUID (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMailboxUsers($mailbox_uuid)
    {
        $this->deleteMailboxUsersWithHttpInfo($mailbox_uuid);
    }

    /**
     * Operation deleteMailboxUsersWithHttpInfo
     *
     * Delete mailbox users except requester
     *
     * @param  string $mailbox_uuid Mailbox UUID (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMailboxUsersWithHttpInfo($mailbox_uuid)
    {
        $returnType = '';
        $request = $this->deleteMailboxUsersRequest($mailbox_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMailboxUsersAsync
     *
     * Delete mailbox users except requester
     *
     * @param  string $mailbox_uuid Mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMailboxUsersAsync($mailbox_uuid)
    {
        return $this->deleteMailboxUsersAsyncWithHttpInfo($mailbox_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMailboxUsersAsyncWithHttpInfo
     *
     * Delete mailbox users except requester
     *
     * @param  string $mailbox_uuid Mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMailboxUsersAsyncWithHttpInfo($mailbox_uuid)
    {
        $returnType = '';
        $request = $this->deleteMailboxUsersRequest($mailbox_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMailboxUsers'
     *
     * @param  string $mailbox_uuid Mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMailboxUsersRequest($mailbox_uuid)
    {
        // verify the required parameter 'mailbox_uuid' is set
        if ($mailbox_uuid === null || (is_array($mailbox_uuid) && count($mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox_uuid when calling deleteMailboxUsers'
            );
        }

        $resourcePath = '/api/v1/mailbox/{mailboxUuid}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxUuid' . '}',
                ObjectSerializer::toPathValue($mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountLogo
     *
     * Retrieve mailbox account logo
     *
     * @param  string $mailbox_uuid mailbox_uuid (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getAccountLogo($mailbox_uuid)
    {
        list($response) = $this->getAccountLogoWithHttpInfo($mailbox_uuid);
        return $response;
    }

    /**
     * Operation getAccountLogoWithHttpInfo
     *
     * Retrieve mailbox account logo
     *
     * @param  string $mailbox_uuid (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountLogoWithHttpInfo($mailbox_uuid)
    {
        $returnType = 'string';
        $request = $this->getAccountLogoRequest($mailbox_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountLogoAsync
     *
     * Retrieve mailbox account logo
     *
     * @param  string $mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountLogoAsync($mailbox_uuid)
    {
        return $this->getAccountLogoAsyncWithHttpInfo($mailbox_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountLogoAsyncWithHttpInfo
     *
     * Retrieve mailbox account logo
     *
     * @param  string $mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountLogoAsyncWithHttpInfo($mailbox_uuid)
    {
        $returnType = 'string';
        $request = $this->getAccountLogoRequest($mailbox_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountLogo'
     *
     * @param  string $mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountLogoRequest($mailbox_uuid)
    {
        // verify the required parameter 'mailbox_uuid' is set
        if ($mailbox_uuid === null || (is_array($mailbox_uuid) && count($mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox_uuid when calling getAccountLogo'
            );
        }

        $resourcePath = '/api/v1/mailbox/logo/{mailboxUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxUuid' . '}',
                ObjectSerializer::toPathValue($mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityLog
     *
     * Audit trail feed for mailbox
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $from A datetime value in &#x27;ISO-8601&#x27; format, lowest record date, default - 3 days ago (optional)
     * @param  string $to A datetime value in &#x27;ISO-8601&#x27; format, highest record date, default - now (optional)
     * @param  int $offset Offset, how much records to skip (optional, default to 0)
     * @param  int $limit Limit, how much records to retrieve, max is 1000 (optional, default to 25)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\PageDTOActivityLogRecordDTO
     */
    public function getActivityLog($mailbox, $from = null, $to = null, $offset = '0', $limit = '25')
    {
        list($response) = $this->getActivityLogWithHttpInfo($mailbox, $from, $to, $offset, $limit);
        return $response;
    }

    /**
     * Operation getActivityLogWithHttpInfo
     *
     * Audit trail feed for mailbox
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $from A datetime value in &#x27;ISO-8601&#x27; format, lowest record date, default - 3 days ago (optional)
     * @param  string $to A datetime value in &#x27;ISO-8601&#x27; format, highest record date, default - now (optional)
     * @param  int $offset Offset, how much records to skip (optional, default to 0)
     * @param  int $limit Limit, how much records to retrieve, max is 1000 (optional, default to 25)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\PageDTOActivityLogRecordDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityLogWithHttpInfo($mailbox, $from = null, $to = null, $offset = '0', $limit = '25')
    {
        $returnType = '\Swagger\Client\Model\PageDTOActivityLogRecordDTO';
        $request = $this->getActivityLogRequest($mailbox, $from, $to, $offset, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PageDTOActivityLogRecordDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityLogAsync
     *
     * Audit trail feed for mailbox
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $from A datetime value in &#x27;ISO-8601&#x27; format, lowest record date, default - 3 days ago (optional)
     * @param  string $to A datetime value in &#x27;ISO-8601&#x27; format, highest record date, default - now (optional)
     * @param  int $offset Offset, how much records to skip (optional, default to 0)
     * @param  int $limit Limit, how much records to retrieve, max is 1000 (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityLogAsync($mailbox, $from = null, $to = null, $offset = '0', $limit = '25')
    {
        return $this->getActivityLogAsyncWithHttpInfo($mailbox, $from, $to, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityLogAsyncWithHttpInfo
     *
     * Audit trail feed for mailbox
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $from A datetime value in &#x27;ISO-8601&#x27; format, lowest record date, default - 3 days ago (optional)
     * @param  string $to A datetime value in &#x27;ISO-8601&#x27; format, highest record date, default - now (optional)
     * @param  int $offset Offset, how much records to skip (optional, default to 0)
     * @param  int $limit Limit, how much records to retrieve, max is 1000 (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityLogAsyncWithHttpInfo($mailbox, $from = null, $to = null, $offset = '0', $limit = '25')
    {
        $returnType = '\Swagger\Client\Model\PageDTOActivityLogRecordDTO';
        $request = $this->getActivityLogRequest($mailbox, $from, $to, $offset, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityLog'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $from A datetime value in &#x27;ISO-8601&#x27; format, lowest record date, default - 3 days ago (optional)
     * @param  string $to A datetime value in &#x27;ISO-8601&#x27; format, highest record date, default - now (optional)
     * @param  int $offset Offset, how much records to skip (optional, default to 0)
     * @param  int $limit Limit, how much records to retrieve, max is 1000 (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityLogRequest($mailbox, $from = null, $to = null, $offset = '0', $limit = '25')
    {
        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getActivityLog'
            );
        }

        $resourcePath = '/api/v1/mailbox/activity-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllForUser
     *
     * Retrieve user's mailboxes list
     *
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\User2MailboxDTO[]
     */
    public function getAllForUser()
    {
        list($response) = $this->getAllForUserWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAllForUserWithHttpInfo
     *
     * Retrieve user's mailboxes list
     *
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\User2MailboxDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllForUserWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\User2MailboxDTO[]';
        $request = $this->getAllForUserRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\User2MailboxDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllForUserAsync
     *
     * Retrieve user's mailboxes list
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllForUserAsync()
    {
        return $this->getAllForUserAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllForUserAsyncWithHttpInfo
     *
     * Retrieve user's mailboxes list
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllForUserAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\User2MailboxDTO[]';
        $request = $this->getAllForUserRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllForUser'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllForUserRequest()
    {

        $resourcePath = '/api/v1/mailbox';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMailboxesByAccount
     *
     * Read list of mailboxes
     *
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\MailboxNameUuidDTO[]
     */
    public function getMailboxesByAccount($uuid)
    {
        list($response) = $this->getMailboxesByAccountWithHttpInfo($uuid);
        return $response;
    }

    /**
     * Operation getMailboxesByAccountWithHttpInfo
     *
     * Read list of mailboxes
     *
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\MailboxNameUuidDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getMailboxesByAccountWithHttpInfo($uuid)
    {
        $returnType = '\Swagger\Client\Model\MailboxNameUuidDTO[]';
        $request = $this->getMailboxesByAccountRequest($uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MailboxNameUuidDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMailboxesByAccountAsync
     *
     * Read list of mailboxes
     *
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMailboxesByAccountAsync($uuid)
    {
        return $this->getMailboxesByAccountAsyncWithHttpInfo($uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMailboxesByAccountAsyncWithHttpInfo
     *
     * Read list of mailboxes
     *
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMailboxesByAccountAsyncWithHttpInfo($uuid)
    {
        $returnType = '\Swagger\Client\Model\MailboxNameUuidDTO[]';
        $request = $this->getMailboxesByAccountRequest($uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMailboxesByAccount'
     *
     * @param  string $uuid UUID of account for which to create a mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMailboxesByAccountRequest($uuid)
    {
        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling getMailboxesByAccount'
            );
        }

        $resourcePath = '/api/v1/mailbox/account/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMailboxesInfoMailbox
     *
     * Retrieve mailboxes info
     *
     * @param  string[] $body body (required)
     * @param  bool $account_name Including account name (optional, default to false)
     * @param  bool $account_itn Including account ITN (optional, default to false)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Swagger\Client\Model\MailboxInfoDTO]
     */
    public function getMailboxesInfoMailbox($body, $account_name = 'false', $account_itn = 'false')
    {
        list($response) = $this->getMailboxesInfoMailboxWithHttpInfo($body, $account_name, $account_itn);
        return $response;
    }

    /**
     * Operation getMailboxesInfoMailboxWithHttpInfo
     *
     * Retrieve mailboxes info
     *
     * @param  string[] $body (required)
     * @param  bool $account_name Including account name (optional, default to false)
     * @param  bool $account_itn Including account ITN (optional, default to false)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Swagger\Client\Model\MailboxInfoDTO], HTTP status code, HTTP response headers (array of strings)
     */
    public function getMailboxesInfoMailboxWithHttpInfo($body, $account_name = 'false', $account_itn = 'false')
    {
        $returnType = 'map[string,\Swagger\Client\Model\MailboxInfoDTO]';
        $request = $this->getMailboxesInfoMailboxRequest($body, $account_name, $account_itn);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Swagger\Client\Model\MailboxInfoDTO]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMailboxesInfoMailboxAsync
     *
     * Retrieve mailboxes info
     *
     * @param  string[] $body (required)
     * @param  bool $account_name Including account name (optional, default to false)
     * @param  bool $account_itn Including account ITN (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMailboxesInfoMailboxAsync($body, $account_name = 'false', $account_itn = 'false')
    {
        return $this->getMailboxesInfoMailboxAsyncWithHttpInfo($body, $account_name, $account_itn)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMailboxesInfoMailboxAsyncWithHttpInfo
     *
     * Retrieve mailboxes info
     *
     * @param  string[] $body (required)
     * @param  bool $account_name Including account name (optional, default to false)
     * @param  bool $account_itn Including account ITN (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMailboxesInfoMailboxAsyncWithHttpInfo($body, $account_name = 'false', $account_itn = 'false')
    {
        $returnType = 'map[string,\Swagger\Client\Model\MailboxInfoDTO]';
        $request = $this->getMailboxesInfoMailboxRequest($body, $account_name, $account_itn);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMailboxesInfoMailbox'
     *
     * @param  string[] $body (required)
     * @param  bool $account_name Including account name (optional, default to false)
     * @param  bool $account_itn Including account ITN (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMailboxesInfoMailboxRequest($body, $account_name = 'false', $account_itn = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getMailboxesInfoMailbox'
            );
        }

        $resourcePath = '/api/v1/mailbox/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($account_name !== null) {
            $queryParams['accountName'] = ObjectSerializer::toQueryValue($account_name, null);
        }
        // query params
        if ($account_itn !== null) {
            $queryParams['accountITN'] = ObjectSerializer::toQueryValue($account_itn, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStat
     *
     * Get number of unread envelopes in every scope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\StatDTO
     */
    public function getStat($mailbox)
    {
        list($response) = $this->getStatWithHttpInfo($mailbox);
        return $response;
    }

    /**
     * Operation getStatWithHttpInfo
     *
     * Get number of unread envelopes in every scope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\StatDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatWithHttpInfo($mailbox)
    {
        $returnType = '\Swagger\Client\Model\StatDTO';
        $request = $this->getStatRequest($mailbox);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatAsync
     *
     * Get number of unread envelopes in every scope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatAsync($mailbox)
    {
        return $this->getStatAsyncWithHttpInfo($mailbox)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatAsyncWithHttpInfo
     *
     * Get number of unread envelopes in every scope
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatAsyncWithHttpInfo($mailbox)
    {
        $returnType = '\Swagger\Client\Model\StatDTO';
        $request = $this->getStatRequest($mailbox);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStat'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatRequest($mailbox)
    {
        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getStat'
            );
        }

        $resourcePath = '/api/v1/mailbox/stat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUsedTemplates
     *
     * List of used templates
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $name Template name to search by (optional)
     * @param  int $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int $limit Limit, how much envelopes to retrieve (optional, default to 25)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\PageDTOUsedTemplateDTO
     */
    public function getUsedTemplates($mailbox, $name = null, $offset = '0', $limit = '25')
    {
        list($response) = $this->getUsedTemplatesWithHttpInfo($mailbox, $name, $offset, $limit);
        return $response;
    }

    /**
     * Operation getUsedTemplatesWithHttpInfo
     *
     * List of used templates
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $name Template name to search by (optional)
     * @param  int $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int $limit Limit, how much envelopes to retrieve (optional, default to 25)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\PageDTOUsedTemplateDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsedTemplatesWithHttpInfo($mailbox, $name = null, $offset = '0', $limit = '25')
    {
        $returnType = '\Swagger\Client\Model\PageDTOUsedTemplateDTO';
        $request = $this->getUsedTemplatesRequest($mailbox, $name, $offset, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PageDTOUsedTemplateDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUsedTemplatesAsync
     *
     * List of used templates
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $name Template name to search by (optional)
     * @param  int $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int $limit Limit, how much envelopes to retrieve (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsedTemplatesAsync($mailbox, $name = null, $offset = '0', $limit = '25')
    {
        return $this->getUsedTemplatesAsyncWithHttpInfo($mailbox, $name, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUsedTemplatesAsyncWithHttpInfo
     *
     * List of used templates
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $name Template name to search by (optional)
     * @param  int $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int $limit Limit, how much envelopes to retrieve (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsedTemplatesAsyncWithHttpInfo($mailbox, $name = null, $offset = '0', $limit = '25')
    {
        $returnType = '\Swagger\Client\Model\PageDTOUsedTemplateDTO';
        $request = $this->getUsedTemplatesRequest($mailbox, $name, $offset, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUsedTemplates'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $name Template name to search by (optional)
     * @param  int $offset Offset, how much envelopes to skip (optional, default to 0)
     * @param  int $limit Limit, how much envelopes to retrieve (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUsedTemplatesRequest($mailbox, $name = null, $offset = '0', $limit = '25')
    {
        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling getUsedTemplates'
            );
        }

        $resourcePath = '/api/v1/mailbox/templates/used';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchMailbox
     *
     * Patch mailbox, return patched mailbox w/o users count
     *
     * @param  \Docstudio\Client\Model\MailboxPatchRequestDTO $body body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\AccountMailboxInfoDTO
     */
    public function patchMailbox($body, $mailbox_uuid)
    {
        list($response) = $this->patchMailboxWithHttpInfo($body, $mailbox_uuid);
        return $response;
    }

    /**
     * Operation patchMailboxWithHttpInfo
     *
     * Patch mailbox, return patched mailbox w/o users count
     *
     * @param  \Docstudio\Client\Model\MailboxPatchRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\AccountMailboxInfoDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchMailboxWithHttpInfo($body, $mailbox_uuid)
    {
        $returnType = '\Swagger\Client\Model\AccountMailboxInfoDTO';
        $request = $this->patchMailboxRequest($body, $mailbox_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AccountMailboxInfoDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchMailboxAsync
     *
     * Patch mailbox, return patched mailbox w/o users count
     *
     * @param  \Docstudio\Client\Model\MailboxPatchRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchMailboxAsync($body, $mailbox_uuid)
    {
        return $this->patchMailboxAsyncWithHttpInfo($body, $mailbox_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchMailboxAsyncWithHttpInfo
     *
     * Patch mailbox, return patched mailbox w/o users count
     *
     * @param  \Docstudio\Client\Model\MailboxPatchRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchMailboxAsyncWithHttpInfo($body, $mailbox_uuid)
    {
        $returnType = '\Swagger\Client\Model\AccountMailboxInfoDTO';
        $request = $this->patchMailboxRequest($body, $mailbox_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchMailbox'
     *
     * @param  \Docstudio\Client\Model\MailboxPatchRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchMailboxRequest($body, $mailbox_uuid)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchMailbox'
            );
        }
        // verify the required parameter 'mailbox_uuid' is set
        if ($mailbox_uuid === null || (is_array($mailbox_uuid) && count($mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox_uuid when calling patchMailbox'
            );
        }

        $resourcePath = '/api/v1/mailbox/{mailboxUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxUuid' . '}',
                ObjectSerializer::toPathValue($mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMailboxes
     *
     * Search mailboxes by name, contact, alias, user
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $q String to search by alias, contact, user email, mailbox name or UUID (optional)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\MailboxSearchResultDTO[]
     */
    public function searchMailboxes($mailbox, $q = null)
    {
        list($response) = $this->searchMailboxesWithHttpInfo($mailbox, $q);
        return $response;
    }

    /**
     * Operation searchMailboxesWithHttpInfo
     *
     * Search mailboxes by name, contact, alias, user
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $q String to search by alias, contact, user email, mailbox name or UUID (optional)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\MailboxSearchResultDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchMailboxesWithHttpInfo($mailbox, $q = null)
    {
        $returnType = '\Swagger\Client\Model\MailboxSearchResultDTO[]';
        $request = $this->searchMailboxesRequest($mailbox, $q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MailboxSearchResultDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchMailboxesAsync
     *
     * Search mailboxes by name, contact, alias, user
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $q String to search by alias, contact, user email, mailbox name or UUID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMailboxesAsync($mailbox, $q = null)
    {
        return $this->searchMailboxesAsyncWithHttpInfo($mailbox, $q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMailboxesAsyncWithHttpInfo
     *
     * Search mailboxes by name, contact, alias, user
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $q String to search by alias, contact, user email, mailbox name or UUID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMailboxesAsyncWithHttpInfo($mailbox, $q = null)
    {
        $returnType = '\Swagger\Client\Model\MailboxSearchResultDTO[]';
        $request = $this->searchMailboxesRequest($mailbox, $q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchMailboxes'
     *
     * @param  string $mailbox Mailbox context, HTTP Header with current mailbox UUID (required)
     * @param  string $q String to search by alias, contact, user email, mailbox name or UUID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchMailboxesRequest($mailbox, $q = null)
    {
        // verify the required parameter 'mailbox' is set
        if ($mailbox === null || (is_array($mailbox) && count($mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox when calling searchMailboxes'
            );
        }

        $resourcePath = '/api/v1/mailbox/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q, null);
        }
        // header params
        if ($mailbox !== null) {
            $headerParams['Mailbox'] = ObjectSerializer::toHeaderValue($mailbox);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMailbox
     *
     * Update mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxUpdateRequestDTO $body body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Docstudio\Client\Model\AccountMailboxInfoDTO
     */
    public function updateMailbox($body, $mailbox_uuid)
    {
        list($response) = $this->updateMailboxWithHttpInfo($body, $mailbox_uuid);
        return $response;
    }

    /**
     * Operation updateMailboxWithHttpInfo
     *
     * Update mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxUpdateRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \Docstudio\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Docstudio\Client\Model\AccountMailboxInfoDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMailboxWithHttpInfo($body, $mailbox_uuid)
    {
        $returnType = '\Swagger\Client\Model\AccountMailboxInfoDTO';
        $request = $this->updateMailboxRequest($body, $mailbox_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AccountMailboxInfoDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateMailboxAsync
     *
     * Update mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxUpdateRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMailboxAsync($body, $mailbox_uuid)
    {
        return $this->updateMailboxAsyncWithHttpInfo($body, $mailbox_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMailboxAsyncWithHttpInfo
     *
     * Update mailbox
     *
     * @param  \Docstudio\Client\Model\MailboxUpdateRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMailboxAsyncWithHttpInfo($body, $mailbox_uuid)
    {
        $returnType = '\Swagger\Client\Model\AccountMailboxInfoDTO';
        $request = $this->updateMailboxRequest($body, $mailbox_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMailbox'
     *
     * @param  \Docstudio\Client\Model\MailboxUpdateRequestDTO $body (required)
     * @param  string $mailbox_uuid UUID of mailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateMailboxRequest($body, $mailbox_uuid)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateMailbox'
            );
        }
        // verify the required parameter 'mailbox_uuid' is set
        if ($mailbox_uuid === null || (is_array($mailbox_uuid) && count($mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailbox_uuid when calling updateMailbox'
            );
        }

        $resourcePath = '/api/v1/mailbox/{mailboxUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxUuid' . '}',
                ObjectSerializer::toPathValue($mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
